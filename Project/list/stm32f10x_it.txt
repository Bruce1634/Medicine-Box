; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o..\obj\stm32f10x_it.o --asm_dir=..\list\ --list_dir=..\list\ --depend=..\obj\stm32f10x_it.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\User\inc -I"D:\Program Files\Keil_v5\ARM\RV31\INC" -I"D:\Program Files\Keil_v5\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include" -I"D:\Program Files\Keil_v5\ARM\Inc\ST\STM32F10x" -DSTM32F10X_MD -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\stm32f10x_it.crf ..\..\User\src\stm32f10x_it.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  NMI_Handler PROC
;;;53       */
;;;54     void NMI_Handler(void)
000000  4770              BX       lr
;;;55     {
;;;56     }
;;;57     
                          ENDP

                  HardFault_Handler PROC
;;;62       */
;;;63     void HardFault_Handler(void)
000002  bf00              NOP      
                  |L1.4|
;;;64     {
;;;65       /* Go to infinite loop when Hard Fault exception occurs */
;;;66       while (1)
000004  e7fe              B        |L1.4|
;;;67       {
;;;68       }
;;;69     }
;;;70     
                          ENDP

                  MemManage_Handler PROC
;;;75       */
;;;76     void MemManage_Handler(void)
000006  bf00              NOP      
                  |L1.8|
;;;77     {
;;;78       /* Go to infinite loop when Memory Manage exception occurs */
;;;79       while (1)
000008  e7fe              B        |L1.8|
;;;80       {
;;;81       }
;;;82     }
;;;83     
                          ENDP

                  BusFault_Handler PROC
;;;88       */
;;;89     void BusFault_Handler(void)
00000a  bf00              NOP      
                  |L1.12|
;;;90     {
;;;91       /* Go to infinite loop when Bus Fault exception occurs */
;;;92       while (1)
00000c  e7fe              B        |L1.12|
;;;93       {
;;;94       }
;;;95     }
;;;96     
                          ENDP

                  UsageFault_Handler PROC
;;;101      */
;;;102    void UsageFault_Handler(void)
00000e  bf00              NOP      
                  |L1.16|
;;;103    {
;;;104      /* Go to infinite loop when Usage Fault exception occurs */
;;;105      while (1)
000010  e7fe              B        |L1.16|
;;;106      {
;;;107      }
;;;108    }
;;;109    
                          ENDP

                  SVC_Handler PROC
;;;114      */
;;;115    void SVC_Handler(void)
000012  4770              BX       lr
;;;116    {
;;;117    }
;;;118    
                          ENDP

                  DebugMon_Handler PROC
;;;123      */
;;;124    void DebugMon_Handler(void)
000014  4770              BX       lr
;;;125    {
;;;126    }
;;;127    
                          ENDP

                  PendSV_Handler PROC
;;;132      */
;;;133    void PendSV_Handler(void)
000016  4770              BX       lr
;;;134    {
;;;135    }
;;;136    
                          ENDP

                  SysTick_Handler PROC
;;;141      */
;;;142    void SysTick_Handler(void)
000018  e92d47f0          PUSH     {r4-r10,lr}
;;;143    {
;;;144    		int32_t temp ;
;;;145    	  int interval , i;
;;;146    		/**********************************DOWN MOTOR POSITION CONTROL*********************************************/
;;;147    	
;;;148    		flag = GPIO_ReadInputDataBit(GPIOC,GPIO_Pin_6);
00001c  2140              MOVS     r1,#0x40
00001e  484c              LDR      r0,|L1.336|
000020  f7fffffe          BL       GPIO_ReadInputDataBit
000024  494b              LDR      r1,|L1.340|
000026  7008              STRB     r0,[r1,#0]
;;;149    	
;;;150    		if(flag == 0)                 //光电开关没有检测到药片
000028  4608              MOV      r0,r1
00002a  7800              LDRB     r0,[r0,#0]  ; flag
00002c  b980              CBNZ     r0,|L1.80|
;;;151        {
;;;152    			count_Up = 0;
00002e  2000              MOVS     r0,#0
000030  4949              LDR      r1,|L1.344|
000032  7008              STRB     r0,[r1,#0]
;;;153    			count_Down ++;
000034  4849              LDR      r0,|L1.348|
000036  7800              LDRB     r0,[r0,#0]  ; count_Down
000038  1c40              ADDS     r0,r0,#1
00003a  4948              LDR      r1,|L1.348|
00003c  7008              STRB     r0,[r1,#0]
;;;154    			if(count_Down > 5)
00003e  4608              MOV      r0,r1
000040  7800              LDRB     r0,[r0,#0]  ; count_Down
000042  2805              CMP      r0,#5
000044  dd1e              BLE      |L1.132|
;;;155          {
;;;156    				count_Down = 0;
000046  2000              MOVS     r0,#0
000048  7008              STRB     r0,[r1,#0]
;;;157    				down_flag = 0;           
00004a  4945              LDR      r1,|L1.352|
00004c  7008              STRB     r0,[r1,#0]
00004e  e019              B        |L1.132|
                  |L1.80|
;;;158          }            
;;;159        }       
;;;160        else                 //光电开关检测到有药片
;;;161        {
;;;162    			count_Up ++;
000050  4841              LDR      r0,|L1.344|
000052  7800              LDRB     r0,[r0,#0]  ; count_Up
000054  1c40              ADDS     r0,r0,#1
000056  4940              LDR      r1,|L1.344|
000058  7008              STRB     r0,[r1,#0]
;;;163    			count_Down = 0;
00005a  2000              MOVS     r0,#0
00005c  493f              LDR      r1,|L1.348|
00005e  7008              STRB     r0,[r1,#0]
;;;164    			if(count_Up > 5)
000060  483d              LDR      r0,|L1.344|
000062  7800              LDRB     r0,[r0,#0]  ; count_Up
000064  2805              CMP      r0,#5
000066  dd0d              BLE      |L1.132|
;;;165          {
;;;166    				count_Up = 0;
000068  2000              MOVS     r0,#0
00006a  493b              LDR      r1,|L1.344|
00006c  7008              STRB     r0,[r1,#0]
;;;167    				if(down_flag == 0)
00006e  483c              LDR      r0,|L1.352|
000070  7800              LDRB     r0,[r0,#0]  ; down_flag
000072  b938              CBNZ     r0,|L1.132|
;;;168    				{
;;;169    					down_flag = 1;
000074  2001              MOVS     r0,#1
000076  493a              LDR      r1,|L1.352|
000078  7008              STRB     r0,[r1,#0]
;;;170    					
;;;171    					n++;
00007a  483a              LDR      r0,|L1.356|
00007c  6800              LDR      r0,[r0,#0]  ; n
00007e  1c40              ADDS     r0,r0,#1
000080  4938              LDR      r1,|L1.356|
000082  6008              STR      r0,[r1,#0]  ; n
                  |L1.132|
;;;172            }  
;;;173    		  }			
;;;174        }
;;;175    		
;;;176    		
;;;177    		i = (long long)position_down.PositionCurrent / interval;
000084  4838              LDR      r0,|L1.360|
000086  e9d02102          LDRD     r2,r1,[r0,#8]
00008a  4610              MOV      r0,r2
00008c  f7fffffe          BL       __aeabi_d2lz
000090  4606              MOV      r6,r0
000092  462a              MOV      r2,r5
000094  17eb              ASRS     r3,r5,#31
000096  f7fffffe          BL       __aeabi_ldivmod
00009a  4680              MOV      r8,r0
;;;178    		position_down.PositionCurrent -= i * interval;
00009c  fb08f005          MUL      r0,r8,r5
0000a0  f7fffffe          BL       __aeabi_i2d
0000a4  4681              MOV      r9,r0
0000a6  4830              LDR      r0,|L1.360|
0000a8  e9d06302          LDRD     r6,r3,[r0,#8]
0000ac  4632              MOV      r2,r6
0000ae  4648              MOV      r0,r9
0000b0  f7fffffe          BL       __aeabi_drsub
0000b4  4a2c              LDR      r2,|L1.360|
0000b6  e9c20102          STRD     r0,r1,[r2,#8]
;;;179    		n -= i;
0000ba  482a              LDR      r0,|L1.356|
0000bc  6800              LDR      r0,[r0,#0]  ; n
0000be  eba00008          SUB      r0,r0,r8
0000c2  4928              LDR      r1,|L1.356|
0000c4  6008              STR      r0,[r1,#0]  ; n
;;;180    		interval = 3670;
0000c6  f6406556          MOV      r5,#0xe56
;;;181    		position_down.PositionExpect = n * interval;
0000ca  6809              LDR      r1,[r1,#0]  ; n
0000cc  fb01f005          MUL      r0,r1,r5
0000d0  f7fffffe          BL       __aeabi_i2d
0000d4  4a24              LDR      r2,|L1.360|
0000d6  c203              STM      r2!,{r0,r1}
;;;182    		DetectVelocity(&motor_down , TIM2);
0000d8  f04f4180          MOV      r1,#0x40000000
0000dc  4823              LDR      r0,|L1.364|
0000de  f7fffffe          BL       DetectVelocity
;;;183    		CalcPositionPID(&position_down , &positionPID_down , &motor_down);
0000e2  4a22              LDR      r2,|L1.364|
0000e4  4922              LDR      r1,|L1.368|
0000e6  4820              LDR      r0,|L1.360|
0000e8  f7fffffe          BL       CalcPositionPID
;;;184    		temp = CalcSpeedPID(&motor_down , &motorPID_down);	
0000ec  4921              LDR      r1,|L1.372|
0000ee  481f              LDR      r0,|L1.364|
0000f0  f7fffffe          BL       CalcSpeedPID
0000f4  4604              MOV      r4,r0
;;;185    		if(temp>=0)
0000f6  2c00              CMP      r4,#0
0000f8  db0b              BLT      |L1.274|
;;;186    		{
;;;187    			temp = temp;
0000fa  bf00              NOP      
;;;188    			GPIO_SetBits(GPIOB, GPIO_Pin_10);
0000fc  f44f6180          MOV      r1,#0x400
000100  481d              LDR      r0,|L1.376|
000102  f7fffffe          BL       GPIO_SetBits
;;;189    			GPIO_ResetBits(GPIOB, GPIO_Pin_11);
000106  f44f6100          MOV      r1,#0x800
00010a  481b              LDR      r0,|L1.376|
00010c  f7fffffe          BL       GPIO_ResetBits
000110  e00a              B        |L1.296|
                  |L1.274|
;;;190    		}
;;;191    	  else
;;;192    		{
;;;193    			temp = -temp;
000112  4264              RSBS     r4,r4,#0
;;;194    			GPIO_SetBits(GPIOB, GPIO_Pin_11);
000114  f44f6100          MOV      r1,#0x800
000118  4817              LDR      r0,|L1.376|
00011a  f7fffffe          BL       GPIO_SetBits
;;;195    			GPIO_ResetBits(GPIOB, GPIO_Pin_10);
00011e  f44f6180          MOV      r1,#0x400
000122  4815              LDR      r0,|L1.376|
000124  f7fffffe          BL       GPIO_ResetBits
                  |L1.296|
;;;196    		}
;;;197    	  TIM4->CCR2 = temp;
000128  4914              LDR      r1,|L1.380|
00012a  800c              STRH     r4,[r1,#0]
;;;198    		
;;;199    		
;;;200    		/******************************* UP MOTOR VELOCITY CONTROL ***************************************/
;;;201    	
;;;202    		DetectVelocity(&motor_up , TIM3);
00012c  4914              LDR      r1,|L1.384|
00012e  4815              LDR      r0,|L1.388|
000130  f7fffffe          BL       DetectVelocity
;;;203    	  TIM4->CCR1 = CalcSpeedPID(&motor_up , &motorPID_up);
000134  4914              LDR      r1,|L1.392|
000136  4813              LDR      r0,|L1.388|
000138  f7fffffe          BL       CalcSpeedPID
00013c  490f              LDR      r1,|L1.380|
00013e  1f09              SUBS     r1,r1,#4
000140  8008              STRH     r0,[r1,#0]
;;;204    		
;;;205    }
000142  e8bd87f0          POP      {r4-r10,pc}
;;;206    
                          ENDP

                  TIM4_IRQHandler PROC
;;;207    void TIM4_IRQHandler(void)
000146  4770              BX       lr
;;;208    {
;;;209    
;;;210    	/*Group_4*/
;;;211    
;;;212    	
;;;213    }
;;;214    
                          ENDP

                  TIM3_IRQHandler PROC
;;;215    void TIM3_IRQHandler(void)
000148  4770              BX       lr
;;;216    {
;;;217    
;;;218    	/*Group_3*/
;;;219    	
;;;220    	
;;;221    }
;;;222    
                          ENDP

                  TIM2_IRQHandler PROC
;;;223    void TIM2_IRQHandler(void)
00014a  4770              BX       lr
;;;224    {
;;;225    	/*Group_2*/
;;;226    
;;;227    
;;;228    	/*Group_1*/
;;;229    
;;;230    	
;;;231    }
;;;232    
                          ENDP

                  TIM1_CC_IRQHandler PROC
;;;233    void TIM1_CC_IRQHandler(void)
00014c  4770              BX       lr
;;;234    {
;;;235    }
;;;236    
                          ENDP

                  USART1_IRQHandler PROC
;;;237    void USART1_IRQHandler(void)
00014e  4770              BX       lr
;;;238    {
;;;239    	
;;;240    }
;;;241    
                          ENDP

                  |L1.336|
                          DCD      0x40011000
                  |L1.340|
                          DCD      flag
                  |L1.344|
                          DCD      count_Up
                  |L1.348|
                          DCD      count_Down
                  |L1.352|
                          DCD      down_flag
                  |L1.356|
                          DCD      n
                  |L1.360|
                          DCD      position_down
                  |L1.364|
                          DCD      motor_down
                  |L1.368|
                          DCD      positionPID_down
                  |L1.372|
                          DCD      motorPID_down
                  |L1.376|
                          DCD      0x40010c00
                  |L1.380|
                          DCD      0x40000838
                  |L1.384|
                          DCD      0x40000400
                  |L1.388|
                          DCD      motor_up
                  |L1.392|
                          DCD      motorPID_up
