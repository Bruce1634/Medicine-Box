; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o..\obj\main.o --depend=..\obj\main.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\User\inc -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\ST\STM32F10x -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\main.crf ..\..\User\src\main.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  SendCommand PROC
;;;572    
;;;573    void SendCommand(int16_t Rstick,int16_t Fstick)
000000  b5fe              PUSH     {r1-r7,lr}
;;;574    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;575    	unsigned char command[] ={0xee,0xaa,0x01,0x00,0x00,0x01,0x00,0x00,0x02,0x00,0x00,0xbb};
000006  a2ff              ADR      r2,|L1.1028|
000008  ca07              LDM      r2,{r0-r2}
00000a  e88d0007          STM      sp,{r0-r2}
;;;576    							// 0	1	 2	  3		4	5	 6	  7	   8	9	 10	  11
;;;577    	uint8_t TxCount = 0;
00000e  2600              MOVS     r6,#0
;;;578    	if(Rstick<0)
000010  2c00              CMP      r4,#0
000012  da04              BGE      |L1.30|
;;;579    	{
;;;580    		command[5] = 0x02;
000014  2002              MOVS     r0,#2
000016  f88d0005          STRB     r0,[sp,#5]
;;;581    		Rstick = -Rstick;
00001a  4260              RSBS     r0,r4,#0
00001c  b204              SXTH     r4,r0
                  |L1.30|
;;;582    	}
;;;583    	if(Fstick<0)
00001e  2d00              CMP      r5,#0
000020  da04              BGE      |L1.44|
;;;584    	{
;;;585    		command[2] = 0x02;
000022  2002              MOVS     r0,#2
000024  f88d0002          STRB     r0,[sp,#2]
;;;586    		Fstick = -Fstick;
000028  4268              RSBS     r0,r5,#0
00002a  b205              SXTH     r5,r0
                  |L1.44|
;;;587    	}
;;;588    
;;;589    	command[4] = Fstick%256;
00002c  4628              MOV      r0,r5
00002e  17e9              ASRS     r1,r5,#31
000030  eb056111          ADD      r1,r5,r1,LSR #24
000034  1209              ASRS     r1,r1,#8
000036  eba52101          SUB      r1,r5,r1,LSL #8
00003a  b2c9              UXTB     r1,r1
00003c  f88d1004          STRB     r1,[sp,#4]
;;;590    	command[3] = Fstick/256;
000040  17e9              ASRS     r1,r5,#31
000042  eb056111          ADD      r1,r5,r1,LSR #24
000046  0a09              LSRS     r1,r1,#8
000048  f88d1003          STRB     r1,[sp,#3]
;;;591    	command[7] = Rstick%256;
00004c  4620              MOV      r0,r4
00004e  17e1              ASRS     r1,r4,#31
000050  eb046111          ADD      r1,r4,r1,LSR #24
000054  1209              ASRS     r1,r1,#8
000056  eba42101          SUB      r1,r4,r1,LSL #8
00005a  b2c9              UXTB     r1,r1
00005c  f88d1007          STRB     r1,[sp,#7]
;;;592    	command[6] = Rstick/256;
000060  17e1              ASRS     r1,r4,#31
000062  eb046111          ADD      r1,r4,r1,LSR #24
000066  0a09              LSRS     r1,r1,#8
000068  f88d1006          STRB     r1,[sp,#6]
;;;593    
;;;594    	while(TxCount < sizeof(command))
00006c  e00d              B        |L1.138|
                  |L1.110|
;;;595    	{
;;;596    		USART_SendData(USART1,command[TxCount]);
00006e  f81d1006          LDRB     r1,[sp,r6]
000072  48e7              LDR      r0,|L1.1040|
000074  f7fffffe          BL       USART_SendData
;;;597    		while(USART_GetFlagStatus(USART1,USART_FLAG_TC) == RESET);
000078  bf00              NOP      
                  |L1.122|
00007a  2140              MOVS     r1,#0x40
00007c  48e4              LDR      r0,|L1.1040|
00007e  f7fffffe          BL       USART_GetFlagStatus
000082  2800              CMP      r0,#0
000084  d0f9              BEQ      |L1.122|
;;;598    		TxCount++;
000086  1c70              ADDS     r0,r6,#1
000088  b2c6              UXTB     r6,r0
                  |L1.138|
00008a  2e0c              CMP      r6,#0xc               ;594
00008c  d3ef              BCC      |L1.110|
;;;599    	}
;;;600    		
;;;601    }
00008e  bdfe              POP      {r1-r7,pc}
;;;602    
                          ENDP

                  delay_us PROC
;;;973    
;;;974    void delay_us(uint16_t ums)
000090  49e0              LDR      r1,|L1.1044|
;;;975    {
;;;976    	TimingDelay = ums;
000092  6008              STR      r0,[r1,#0]  ; TimingDelay
;;;977    	SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk;
000094  f04f21e0          MOV      r1,#0xe000e000
000098  6909              LDR      r1,[r1,#0x10]
00009a  f0410101          ORR      r1,r1,#1
00009e  f04f22e0          MOV      r2,#0xe000e000
0000a2  6111              STR      r1,[r2,#0x10]
;;;978    	while(TimingDelay != 0);
0000a4  bf00              NOP      
                  |L1.166|
0000a6  49db              LDR      r1,|L1.1044|
0000a8  6809              LDR      r1,[r1,#0]  ; TimingDelay
0000aa  2900              CMP      r1,#0
0000ac  d1fb              BNE      |L1.166|
;;;979    }
0000ae  4770              BX       lr
;;;980    
                          ENDP

                  NVIC_Configuration PROC
;;;893    
;;;894    void NVIC_Configuration(void)					   					//配置中断优先级
0000b0  b508              PUSH     {r3,lr}
;;;895    {
;;;896    	NVIC_InitTypeDef NVIC_InitStructure;
;;;897    	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);				   //抢断1位，响应3位
0000b2  f44f60c0          MOV      r0,#0x600
0000b6  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;898    
;;;899    //	NVIC_InitStructure.NVIC_IRQChannel = TIM1_CC_IRQn;
;;;900    //	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
;;;901    //	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;902    //	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;903    //	NVIC_Init(&NVIC_InitStructure);
;;;904    
;;;905    	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
0000ba  2025              MOVS     r0,#0x25
0000bc  f88d0000          STRB     r0,[sp,#0]
;;;906    	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
0000c0  2000              MOVS     r0,#0
0000c2  f88d0001          STRB     r0,[sp,#1]
;;;907    	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
0000c6  f88d0002          STRB     r0,[sp,#2]
;;;908    	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
0000ca  2001              MOVS     r0,#1
0000cc  f88d0003          STRB     r0,[sp,#3]
;;;909    	NVIC_Init(&NVIC_InitStructure);
0000d0  4668              MOV      r0,sp
0000d2  f7fffffe          BL       NVIC_Init
;;;910    //
;;;911    //	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
;;;912    //	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;913    //	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
;;;914    //	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;915    //	NVIC_Init(&NVIC_InitStructure);
;;;916    //
;;;917    //	NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
;;;918    //	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;919    //	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
;;;920    //	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;921    //	NVIC_Init(&NVIC_InitStructure);
;;;922    //
;;;923    //	NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn;
;;;924    //	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
;;;925    //	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
;;;926    //	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
;;;927    	NVIC_Init(&NVIC_InitStructure);
0000d6  4668              MOV      r0,sp
0000d8  f7fffffe          BL       NVIC_Init
;;;928    }
0000dc  bd08              POP      {r3,pc}
;;;929    
                          ENDP

                  TIM2_Configuration PROC
;;;744    
;;;745    void TIM2_Configuration(void)
0000de  b50e              PUSH     {r1-r3,lr}
;;;746    {
;;;747    	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;					//定时器初始化结构
;;;748        TIM_ICInitTypeDef TIM_ICInitStructure;        					//通道输入初始化结构
;;;749    
;;;750        //TIM2输出初始化
;;;751        TIM_TimeBaseStructure.TIM_Period = 0xFFFF;     					//周期0～FFFF
0000e0  f64f70ff          MOV      r0,#0xffff
0000e4  f8ad0004          STRH     r0,[sp,#4]
;;;752        TIM_TimeBaseStructure.TIM_Prescaler = 71;       				//时钟分频
0000e8  2047              MOVS     r0,#0x47
0000ea  f8ad0000          STRH     r0,[sp,#0]
;;;753        TIM_TimeBaseStructure.TIM_ClockDivision = 0;   					//时钟分割
0000ee  2000              MOVS     r0,#0
0000f0  f8ad0006          STRH     r0,[sp,#6]
;;;754        TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;		//模式
0000f4  f8ad0002          STRH     r0,[sp,#2]
;;;755        TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);					//基本初始化
0000f8  4669              MOV      r1,sp
0000fa  f04f4080          MOV      r0,#0x40000000
0000fe  f7fffffe          BL       TIM_TimeBaseInit
;;;756    
;;;757    //	//TIM2通道的捕捉初始化  
;;;758    //    TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;				//通道选择
;;;759    //    TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;		//边沿触发
;;;760    //    TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; //管脚与寄存器对应关系
;;;761    //    TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			//分频器
;;;762    //    TIM_ICInitStructure.TIM_ICFilter = 0x0;        					//滤波设置，经历几个周期跳变认定波形稳定0x0～0xF
;;;763    //    TIM_ICInit(TIM2, &TIM_ICInitStructure);        					//初始化
;;;764    //
;;;765    //	TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;				//通道选择
;;;766    //    TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Falling;	//边沿触发
;;;767    //    TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; //管脚与寄存器对应关系
;;;768    //    TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			//分频器
;;;769    //    TIM_ICInitStructure.TIM_ICFilter = 0x0;        					//滤波设置，经历几个周期跳变认定波形稳定0x0～0xF
;;;770    //    TIM_ICInit(TIM2, &TIM_ICInitStructure);        					//初始化
;;;771    //
;;;772    //    TIM_ICInitStructure.TIM_Channel = TIM_Channel_3;				//通道选择
;;;773    //    TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;		//边沿触发
;;;774    //    TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; //管脚与寄存器对应关系
;;;775    //    TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			//分频器
;;;776    //    TIM_ICInitStructure.TIM_ICFilter = 0x0;        					//滤波设置，经历几个周期跳变认定波形稳定0x0～0xF
;;;777    //    TIM_ICInit(TIM2, &TIM_ICInitStructure);        					//初始化
;;;778    //
;;;779    //	TIM_ICInitStructure.TIM_Channel = TIM_Channel_4;				//通道选择
;;;780    //    TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Falling;	//边沿触发
;;;781    //    TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; //管脚与寄存器对应关系
;;;782    //    TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			//分频器
;;;783    //    TIM_ICInitStructure.TIM_ICFilter = 0x0;        					//滤波设置，经历几个周期跳变认定波形稳定0x0～0xF
;;;784    //    TIM_ICInit(TIM2, &TIM_ICInitStructure);        					//初始化
;;;785    //  
;;;786    //    TIM_ITConfig(TIM2, TIM_IT_CC1, ENABLE);        					//打开中断
;;;787    //	TIM_ITConfig(TIM2, TIM_IT_CC2, ENABLE);        					//打开中断
;;;788    //
;;;789    //    TIM_ITConfig(TIM2, TIM_IT_CC3, ENABLE);        					//打开中断
;;;790    //	TIM_ITConfig(TIM2, TIM_IT_CC4, ENABLE);        					//打开中断
;;;791      
;;;792    //    TIM_Cmd(TIM2, ENABLE);                         					//启动TIM2	
;;;793    }
000102  bd0e              POP      {r1-r3,pc}
;;;794    
                          ENDP

                  USART_Configuration PROC
;;;930    
;;;931    void USART_Configuration(void)
000104  b500              PUSH     {lr}
;;;932    {
000106  b085              SUB      sp,sp,#0x14
;;;933    	USART_InitTypeDef USART_InitStructure;
;;;934    
;;;935    	GPIO_InitTypeDef GPIO_InitStructure;
;;;936    	
;;;937    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000108  f44f7000          MOV      r0,#0x200
00010c  f8ad0000          STRH     r0,[sp,#0]
;;;938    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000110  2018              MOVS     r0,#0x18
000112  f88d0003          STRB     r0,[sp,#3]
;;;939    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000116  2003              MOVS     r0,#3
000118  f88d0002          STRB     r0,[sp,#2]
;;;940    	GPIO_Init(GPIOA, &GPIO_InitStructure);
00011c  4669              MOV      r1,sp
00011e  48be              LDR      r0,|L1.1048|
000120  f7fffffe          BL       GPIO_Init
;;;941    
;;;942    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000124  f44f6080          MOV      r0,#0x400
000128  f8ad0000          STRH     r0,[sp,#0]
;;;943    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00012c  2004              MOVS     r0,#4
00012e  f88d0003          STRB     r0,[sp,#3]
;;;944    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000132  2003              MOVS     r0,#3
000134  f88d0002          STRB     r0,[sp,#2]
;;;945    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000138  4669              MOV      r1,sp
00013a  48b7              LDR      r0,|L1.1048|
00013c  f7fffffe          BL       GPIO_Init
;;;946    
;;;947    	USART_InitStructure.USART_BaudRate = 19200;
000140  f44f4096          MOV      r0,#0x4b00
000144  9001              STR      r0,[sp,#4]
;;;948    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000146  2000              MOVS     r0,#0
000148  f8ad0008          STRH     r0,[sp,#8]
;;;949    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00014c  f8ad000a          STRH     r0,[sp,#0xa]
;;;950    	USART_InitStructure.USART_Parity = USART_Parity_No;
000150  f8ad000c          STRH     r0,[sp,#0xc]
;;;951    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000154  f8ad0010          STRH     r0,[sp,#0x10]
;;;952    	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;
000158  200c              MOVS     r0,#0xc
00015a  f8ad000e          STRH     r0,[sp,#0xe]
;;;953    
;;;954    	USART_Init(USART1, &USART_InitStructure);
00015e  a901              ADD      r1,sp,#4
000160  48ab              LDR      r0,|L1.1040|
000162  f7fffffe          BL       USART_Init
;;;955    
;;;956    }
000166  b005              ADD      sp,sp,#0x14
000168  bd00              POP      {pc}
;;;957    
                          ENDP

                  SysTick_Init PROC
;;;958    void SysTick_Init(void)
00016a  49ac              LDR      r1,|L1.1052|
;;;959    {
;;;960    	if(SysTick_Config(SystemCoreClock / 1000000))
00016c  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
00016e  4aac              LDR      r2,|L1.1056|
000170  fbb1f0f2          UDIV     r0,r1,r2
000174  f1b07f80          CMP      r0,#0x1000000
000178  d301              BCC      |L1.382|
00017a  2101              MOVS     r1,#1
00017c  e01c              B        |L1.440|
                  |L1.382|
00017e  f020417f          BIC      r1,r0,#0xff000000
000182  1e49              SUBS     r1,r1,#1
000184  f04f22e0          MOV      r2,#0xe000e000
000188  6151              STR      r1,[r2,#0x14]
00018a  bf00              NOP      
00018c  1751              ASRS     r1,r2,#29
00018e  2900              CMP      r1,#0
000190  da05              BGE      |L1.414|
000192  210f              MOVS     r1,#0xf
000194  0109              LSLS     r1,r1,#4
000196  4aa3              LDR      r2,|L1.1060|
000198  230b              MOVS     r3,#0xb
00019a  54d1              STRB     r1,[r2,r3]
00019c  e004              B        |L1.424|
                  |L1.414|
00019e  210f              MOVS     r1,#0xf
0001a0  0109              LSLS     r1,r1,#4
0001a2  4aa1              LDR      r2,|L1.1064|
0001a4  1753              ASRS     r3,r2,#29
0001a6  54d1              STRB     r1,[r2,r3]
                  |L1.424|
0001a8  bf00              NOP      
0001aa  2100              MOVS     r1,#0
0001ac  f04f22e0          MOV      r2,#0xe000e000
0001b0  6191              STR      r1,[r2,#0x18]
0001b2  2107              MOVS     r1,#7
0001b4  6111              STR      r1,[r2,#0x10]
0001b6  2100              MOVS     r1,#0
                  |L1.440|
0001b8  b109              CBZ      r1,|L1.446|
;;;961    	{
;;;962    		while(1);
0001ba  bf00              NOP      
                  |L1.444|
0001bc  e7fe              B        |L1.444|
                  |L1.446|
;;;963    	}
;;;964    	SysTick->CTRL &= ~ SysTick_CTRL_ENABLE_Msk;
0001be  f04f20e0          MOV      r0,#0xe000e000
0001c2  6900              LDR      r0,[r0,#0x10]
0001c4  f0200001          BIC      r0,r0,#1
0001c8  f04f21e0          MOV      r1,#0xe000e000
0001cc  6108              STR      r0,[r1,#0x10]
;;;965    }
0001ce  4770              BX       lr
;;;966    
                          ENDP

                  GPIO_Configuration PROC
;;;712    
;;;713    void GPIO_Configuration(void)
0001d0  b508              PUSH     {r3,lr}
;;;714    {
;;;715    	GPIO_InitTypeDef GPIO_InitStructure;
;;;716    	
;;;717    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4\
0001d2  f643707f          MOV      r0,#0x3f7f
0001d6  f8ad0000          STRH     r0,[sp,#0]
;;;718    									|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_8|GPIO_Pin_9\
;;;719    									|GPIO_Pin_10|GPIO_Pin_11|GPIO_Pin_12|GPIO_Pin_13;  	
;;;720    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
0001da  2010              MOVS     r0,#0x10
0001dc  f88d0003          STRB     r0,[sp,#3]
;;;721    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0001e0  2003              MOVS     r0,#3
0001e2  f88d0002          STRB     r0,[sp,#2]
;;;722    	GPIO_Init(GPIOC, &GPIO_InitStructure);							//PC0_PC12输出模式
0001e6  4669              MOV      r1,sp
0001e8  4890              LDR      r0,|L1.1068|
0001ea  f7fffffe          BL       GPIO_Init
;;;723    	
;;;724    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_6|GPIO_Pin_7|GPIO_Pin_2|GPIO_Pin_3;					
0001ee  20cf              MOVS     r0,#0xcf
0001f0  f8ad0000          STRH     r0,[sp,#0]
;;;725    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
0001f4  2004              MOVS     r0,#4
0001f6  f88d0003          STRB     r0,[sp,#3]
;;;726    	GPIO_Init(GPIOA, &GPIO_InitStructure);						   //PA0\1\6\7\8\11输入模式
0001fa  4669              MOV      r1,sp
0001fc  4886              LDR      r0,|L1.1048|
0001fe  f7fffffe          BL       GPIO_Init
;;;727    
;;;728    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6|GPIO_Pin_7;					
000202  20c0              MOVS     r0,#0xc0
000204  f8ad0000          STRH     r0,[sp,#0]
;;;729    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000208  2004              MOVS     r0,#4
00020a  f88d0003          STRB     r0,[sp,#3]
;;;730    	GPIO_Init(GPIOB, &GPIO_InitStructure);						   //PB6\7输入模式，捕获中断
00020e  4669              MOV      r1,sp
000210  4887              LDR      r0,|L1.1072|
000212  f7fffffe          BL       GPIO_Init
;;;731    
;;;732    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3;					
000216  200f              MOVS     r0,#0xf
000218  f8ad0000          STRH     r0,[sp,#0]
;;;733    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00021c  2010              MOVS     r0,#0x10
00021e  f88d0003          STRB     r0,[sp,#3]
;;;734    	GPIO_Init(GPIOB, &GPIO_InitStructure);						   //PB0\1\2\3推挽输出，选通对应的Echo
000222  4669              MOV      r1,sp
000224  4882              LDR      r0,|L1.1072|
000226  f7fffffe          BL       GPIO_Init
;;;735    
;;;736    	GPIO_ResetBits(GPIOB,GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3);//初始化控制电平为低
00022a  210f              MOVS     r1,#0xf
00022c  4880              LDR      r0,|L1.1072|
00022e  f7fffffe          BL       GPIO_ResetBits
;;;737    
;;;738    	GPIO_ResetBits(GPIOC,GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_2|GPIO_Pin_3|GPIO_Pin_4\
000232  f643717f          MOV      r1,#0x3f7f
000236  487d              LDR      r0,|L1.1068|
000238  f7fffffe          BL       GPIO_ResetBits
;;;739    									|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_13|GPIO_Pin_8|GPIO_Pin_9\
;;;740    									|GPIO_Pin_10|GPIO_Pin_11|GPIO_Pin_12);
;;;741    																   //初始化控制电平为低
;;;742    									   
;;;743    }
00023c  bd08              POP      {r3,pc}
;;;744    
                          ENDP

                  RCC_Configuration PROC
;;;705    
;;;706    void RCC_Configuration(void)
00023e  b510              PUSH     {r4,lr}
;;;707    {
;;;708     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | RCC_APB2Periph_TIM1, ENABLE);
000240  2101              MOVS     r1,#1
000242  f644001c          MOV      r0,#0x481c
000246  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;709    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2 | RCC_APB1Periph_TIM3  | RCC_APB1Periph_TIM4, ENABLE);
00024a  2101              MOVS     r1,#1
00024c  2007              MOVS     r0,#7
00024e  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;710    
;;;711    }
000252  bd10              POP      {r4,pc}
;;;712    
                          ENDP

                  main PROC
;;;66     
;;;67     int main()
000254  b090              SUB      sp,sp,#0x40
;;;68     {
;;;69     	int i;
;;;70         RCC_Configuration();
000256  f7fffffe          BL       RCC_Configuration
;;;71         GPIO_Configuration();
00025a  f7fffffe          BL       GPIO_Configuration
;;;72     
;;;73     	SysTick_Init();
00025e  f7fffffe          BL       SysTick_Init
;;;74     
;;;75     	USART_Configuration();
000262  f7fffffe          BL       USART_Configuration
;;;76     //    TIM1_Configuration();			  		 //影响串口通信，禁用
;;;77     	TIM2_Configuration();
000266  f7fffffe          BL       TIM2_Configuration
;;;78     //	TIM3_Configuration();
;;;79     //	TIM4_Configuration();
;;;80     	NVIC_Configuration();
00026a  f7fffffe          BL       NVIC_Configuration
;;;81     
;;;82     	USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);//开启串口接收中断
00026e  2201              MOVS     r2,#1
000270  f2405125          MOV      r1,#0x525
000274  4866              LDR      r0,|L1.1040|
000276  f7fffffe          BL       USART_ITConfig
;;;83     	USART_Cmd(USART1, ENABLE);
00027a  2101              MOVS     r1,#1
00027c  4864              LDR      r0,|L1.1040|
00027e  f7fffffe          BL       USART_Cmd
;;;84     
;;;85     	RxCtl.cnt = 0;
000282  2000              MOVS     r0,#0
000284  496b              LDR      r1,|L1.1076|
000286  73c8              STRB     r0,[r1,#0xf]
;;;86     	RxCtl.finish = 1;
000288  2001              MOVS     r0,#1
00028a  7408              STRB     r0,[r1,#0x10]
;;;87     	
;;;88     	for(i=0;i<6;i++)			  //0-5,-90-(-15)
00028c  2600              MOVS     r6,#0
00028e  e011              B        |L1.692|
                  |L1.656|
;;;89     	{
;;;90     		s[i].theta = -15*(6-i);	  //逆时针方向为正角度；
000290  f1c60006          RSB      r0,r6,#6
000294  eba01000          SUB      r0,r0,r0,LSL #4
000298  b200              SXTH     r0,r0
00029a  eb060146          ADD      r1,r6,r6,LSL #1
00029e  4a66              LDR      r2,|L1.1080|
0002a0  eb0201c1          ADD      r1,r2,r1,LSL #3
0002a4  8248              STRH     r0,[r1,#0x12]
;;;91     		s[i].echo = 0;
0002a6  2000              MOVS     r0,#0
0002a8  eb060146          ADD      r1,r6,r6,LSL #1
0002ac  eb0201c1          ADD      r1,r2,r1,LSL #3
0002b0  7408              STRB     r0,[r1,#0x10]
0002b2  1c76              ADDS     r6,r6,#1              ;88
                  |L1.692|
0002b4  2e06              CMP      r6,#6                 ;88
0002b6  dbeb              BLT      |L1.656|
;;;92     	}
;;;93     	for(i=6;i<13;i++)	  		  //初始化探头角度 6-12,0-90
0002b8  2606              MOVS     r6,#6
0002ba  e010              B        |L1.734|
                  |L1.700|
;;;94     	{							 
;;;95     		s[i].theta = 15*(i-6);	  //逆时针方向为正角度；
0002bc  1fb0              SUBS     r0,r6,#6
0002be  ebc01000          RSB      r0,r0,r0,LSL #4
0002c2  b200              SXTH     r0,r0
0002c4  eb060146          ADD      r1,r6,r6,LSL #1
0002c8  4a5b              LDR      r2,|L1.1080|
0002ca  eb0201c1          ADD      r1,r2,r1,LSL #3
0002ce  8248              STRH     r0,[r1,#0x12]
;;;96     		s[i].echo = 0;
0002d0  2000              MOVS     r0,#0
0002d2  eb060146          ADD      r1,r6,r6,LSL #1
0002d6  eb0201c1          ADD      r1,r2,r1,LSL #3
0002da  7408              STRB     r0,[r1,#0x10]
0002dc  1c76              ADDS     r6,r6,#1              ;93
                  |L1.734|
0002de  2e0d              CMP      r6,#0xd               ;93
0002e0  dbec              BLT      |L1.700|
;;;97     	}	
;;;98     
;;;99     	while(1)
0002e2  e3fd              B        |L1.2784|
                  |L1.740|
;;;100    	{	
;;;101    		fire0=fire1=fire2=fire3=0;
0002e4  2000              MOVS     r0,#0
0002e6  4955              LDR      r1,|L1.1084|
0002e8  7008              STRB     r0,[r1,#0]
0002ea  4955              LDR      r1,|L1.1088|
0002ec  7008              STRB     r0,[r1,#0]
0002ee  4955              LDR      r1,|L1.1092|
0002f0  7008              STRB     r0,[r1,#0]
0002f2  4955              LDR      r1,|L1.1096|
0002f4  7008              STRB     r0,[r1,#0]
;;;102    		end0=end1=end2=end3=0;
0002f6  4955              LDR      r1,|L1.1100|
0002f8  7008              STRB     r0,[r1,#0]
0002fa  4955              LDR      r1,|L1.1104|
0002fc  7008              STRB     r0,[r1,#0]
0002fe  4955              LDR      r1,|L1.1108|
000300  7008              STRB     r0,[r1,#0]
000302  4955              LDR      r1,|L1.1112|
000304  7008              STRB     r0,[r1,#0]
;;;103    		allfire=allend=0;			  //复位所有标志位
000306  4955              LDR      r1,|L1.1116|
000308  7008              STRB     r0,[r1,#0]
00030a  4955              LDR      r1,|L1.1120|
00030c  7008              STRB     r0,[r1,#0]
;;;104    		safe = 0;
00030e  4955              LDR      r1,|L1.1124|
000310  7008              STRB     r0,[r1,#0]
;;;105    		Lfound = Rfound =0;
000312  4955              LDR      r1,|L1.1128|
000314  7008              STRB     r0,[r1,#0]
000316  4955              LDR      r1,|L1.1132|
000318  7008              STRB     r0,[r1,#0]
;;;106    	//	TIM1->CNT = 0;
;;;107    		TIM2->CNT = 0;
00031a  f04f4180          MOV      r1,#0x40000000
00031e  8488              STRH     r0,[r1,#0x24]
;;;108    //		TIM3->CNT = 0;
;;;109    //		TIM4->CNT = 0;
;;;110    		index = sequence % 4;
000320  4953              LDR      r1,|L1.1136|
000322  8808              LDRH     r0,[r1,#0]  ; sequence
000324  17c1              ASRS     r1,r0,#31
000326  eb007191          ADD      r1,r0,r1,LSR #30
00032a  1089              ASRS     r1,r1,#2
00032c  eba00181          SUB      r1,r0,r1,LSL #2
000330  4a50              LDR      r2,|L1.1140|
000332  8011              STRH     r1,[r2,#0]
;;;111    		TIM_Cmd(TIM2, ENABLE);
000334  2101              MOVS     r1,#1
000336  0788              LSLS     r0,r1,#30
000338  f7fffffe          BL       TIM_Cmd
;;;112    
;;;113    
;;;114    
;;;115    	    switch(index)				  //选择对应组开启高电平触发
00033c  484d              LDR      r0,|L1.1140|
00033e  8800              LDRH     r0,[r0,#0]  ; index
000340  b130              CBZ      r0,|L1.848|
000342  2801              CMP      r0,#1
000344  d009              BEQ      |L1.858|
000346  2802              CMP      r0,#2
000348  d00c              BEQ      |L1.868|
00034a  2803              CMP      r0,#3
00034c  d114              BNE      |L1.888|
00034e  e00e              B        |L1.878|
                  |L1.848|
;;;116    		{
;;;117    			case 0:
;;;118    				GPIO_SetBits(GPIOC,GPIO_Pin_0);break;		 //每一组的1号探头开启
000350  2101              MOVS     r1,#1
000352  4836              LDR      r0,|L1.1068|
000354  f7fffffe          BL       GPIO_SetBits
000358  e00e              B        |L1.888|
                  |L1.858|
;;;119    			case 1:											 
;;;120    				GPIO_SetBits(GPIOC,GPIO_Pin_1);break;		 //每一组的2号探头开启
00035a  2102              MOVS     r1,#2
00035c  4833              LDR      r0,|L1.1068|
00035e  f7fffffe          BL       GPIO_SetBits
000362  e009              B        |L1.888|
                  |L1.868|
;;;121    			case 2:
;;;122    				GPIO_SetBits(GPIOC,GPIO_Pin_2);break;		 //每一组的3号探头开启
000364  2104              MOVS     r1,#4
000366  4831              LDR      r0,|L1.1068|
000368  f7fffffe          BL       GPIO_SetBits
00036c  e004              B        |L1.888|
                  |L1.878|
;;;123    			case 3:
;;;124    				GPIO_SetBits(GPIOC,GPIO_Pin_3);break;		 //每一组的4号探头开启
00036e  2108              MOVS     r1,#8
000370  482e              LDR      r0,|L1.1068|
000372  f7fffffe          BL       GPIO_SetBits
000376  bf00              NOP      
                  |L1.888|
000378  bf00              NOP                            ;118
;;;125    		}
;;;126    	
;;;127    		delay_us(10);				  //保持10us以上高电平
00037a  200a              MOVS     r0,#0xa
00037c  f7fffffe          BL       delay_us
;;;128    	
;;;129    		switch(index)				  //选择对应组关闭高电平触发
000380  483c              LDR      r0,|L1.1140|
000382  8800              LDRH     r0,[r0,#0]  ; index
000384  b130              CBZ      r0,|L1.916|
000386  2801              CMP      r0,#1
000388  d009              BEQ      |L1.926|
00038a  2802              CMP      r0,#2
00038c  d00c              BEQ      |L1.936|
00038e  2803              CMP      r0,#3
000390  d114              BNE      |L1.956|
000392  e00e              B        |L1.946|
                  |L1.916|
;;;130    		{
;;;131    			case 0:
;;;132    				GPIO_ResetBits(GPIOC,GPIO_Pin_0);break;		//每一组的1号探头关闭
000394  2101              MOVS     r1,#1
000396  4825              LDR      r0,|L1.1068|
000398  f7fffffe          BL       GPIO_ResetBits
00039c  e00e              B        |L1.956|
                  |L1.926|
;;;133    			case 1:
;;;134    				GPIO_ResetBits(GPIOC,GPIO_Pin_1);break;		//每一组的2号探头关闭
00039e  2102              MOVS     r1,#2
0003a0  4822              LDR      r0,|L1.1068|
0003a2  f7fffffe          BL       GPIO_ResetBits
0003a6  e009              B        |L1.956|
                  |L1.936|
;;;135    			case 2:
;;;136    				GPIO_ResetBits(GPIOC,GPIO_Pin_2);break;		//每一组的3号探头关闭
0003a8  2104              MOVS     r1,#4
0003aa  4820              LDR      r0,|L1.1068|
0003ac  f7fffffe          BL       GPIO_ResetBits
0003b0  e004              B        |L1.956|
                  |L1.946|
;;;137    			case 3:
;;;138    				GPIO_ResetBits(GPIOC,GPIO_Pin_3);break;		//每一组的4号探头关闭
0003b2  2108              MOVS     r1,#8
0003b4  481d              LDR      r0,|L1.1068|
0003b6  f7fffffe          BL       GPIO_ResetBits
0003ba  bf00              NOP      
                  |L1.956|
0003bc  bf00              NOP                            ;132
;;;139    		}
;;;140    		
;;;141    		while(0 == allfire)		 	//查询是否点火成功
0003be  e0e8              B        |L1.1426|
                  |L1.960|
;;;142    		{
;;;143    			if(0 == fire0)
0003c0  4821              LDR      r0,|L1.1096|
0003c2  7800              LDRB     r0,[r0,#0]  ; fire0
0003c4  b9e8              CBNZ     r0,|L1.1026|
;;;144    			{
;;;145    				if(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)==1) //Group_0: 0,1,2,3
0003c6  2101              MOVS     r1,#1
0003c8  4813              LDR      r0,|L1.1048|
0003ca  f7fffffe          BL       GPIO_ReadInputDataBit
0003ce  2801              CMP      r0,#1
0003d0  d158              BNE      |L1.1156|
;;;146    				{
;;;147    					s[index].beggin = TIM2->CNT;	//如果高电平触发，开始计时
0003d2  0780              LSLS     r0,r0,#30
0003d4  8c80              LDRH     r0,[r0,#0x24]
0003d6  4927              LDR      r1,|L1.1140|
0003d8  8809              LDRH     r1,[r1,#0]  ; index
0003da  eb010141          ADD      r1,r1,r1,LSL #1
0003de  4a16              LDR      r2,|L1.1080|
0003e0  eb0201c1          ADD      r1,r2,r1,LSL #3
0003e4  8088              STRH     r0,[r1,#4]
;;;148    					s[index].echo++;
0003e6  4823              LDR      r0,|L1.1140|
0003e8  8800              LDRH     r0,[r0,#0]  ; index
0003ea  eb000040          ADD      r0,r0,r0,LSL #1
0003ee  4611              MOV      r1,r2
0003f0  eb0100c0          ADD      r0,r1,r0,LSL #3
0003f4  7c00              LDRB     r0,[r0,#0x10]
0003f6  1c40              ADDS     r0,r0,#1
0003f8  491e              LDR      r1,|L1.1140|
0003fa  8809              LDRH     r1,[r1,#0]  ; index
0003fc  eb010141          ADD      r1,r1,r1,LSL #1
000400  e03a              B        |L1.1144|
                  |L1.1026|
000402  e03f              B        |L1.1156|
                  |L1.1028|
000404  eeaa0100          DCB      238,170,1,0
000408  00                DCB      0
000409  0100              DCB      1,0
00040b  00                DCB      0
00040c  0200              DCB      2,0
00040e  00                DCB      0
00040f  bb                DCB      187
                  |L1.1040|
                          DCD      0x40013800
                  |L1.1044|
                          DCD      TimingDelay
                  |L1.1048|
                          DCD      0x40010800
                  |L1.1052|
                          DCD      SystemCoreClock
                  |L1.1056|
                          DCD      0x000f4240
                  |L1.1060|
                          DCD      0xe000ed18
                  |L1.1064|
                          DCD      0xe000e400
                  |L1.1068|
                          DCD      0x40011000
                  |L1.1072|
                          DCD      0x40010c00
                  |L1.1076|
                          DCD      RxCtl
                  |L1.1080|
                          DCD      s
                  |L1.1084|
                          DCD      fire3
                  |L1.1088|
                          DCD      fire2
                  |L1.1092|
                          DCD      fire1
                  |L1.1096|
                          DCD      fire0
                  |L1.1100|
                          DCD      end3
                  |L1.1104|
                          DCD      end2
                  |L1.1108|
                          DCD      end1
                  |L1.1112|
                          DCD      end0
                  |L1.1116|
                          DCD      allend
                  |L1.1120|
                          DCD      allfire
                  |L1.1124|
                          DCD      safe
                  |L1.1128|
                          DCD      Rfound
                  |L1.1132|
                          DCD      Lfound
                  |L1.1136|
                          DCD      sequence
                  |L1.1140|
                          DCD      index
                  |L1.1144|
000478  eb0201c1          ADD      r1,r2,r1,LSL #3
00047c  7408              STRB     r0,[r1,#0x10]
;;;149    					fire0 = 1;
00047e  2001              MOVS     r0,#1
000480  49fa              LDR      r1,|L1.2156|
000482  7008              STRB     r0,[r1,#0]
                  |L1.1156|
;;;150    //				test();						//置为点火标志
;;;151    				}
;;;152    			}
;;;153    			if(0 == fire1)
000484  48fa              LDR      r0,|L1.2160|
000486  7800              LDRB     r0,[r0,#0]  ; fire1
000488  bb30              CBNZ     r0,|L1.1240|
;;;154    			{
;;;155    				if(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_1)==1) //Group_1: 4,5,6,7
00048a  2102              MOVS     r1,#2
00048c  48f9              LDR      r0,|L1.2164|
00048e  f7fffffe          BL       GPIO_ReadInputDataBit
000492  2801              CMP      r0,#1
000494  d120              BNE      |L1.1240|
;;;156    				{
;;;157    					s[index+4].beggin = TIM2->CNT;	//如果高电平触发，开始计时
000496  0780              LSLS     r0,r0,#30
000498  8c81              LDRH     r1,[r0,#0x24]
00049a  48f7              LDR      r0,|L1.2168|
00049c  8800              LDRH     r0,[r0,#0]  ; index
00049e  1d00              ADDS     r0,r0,#4
0004a0  eb000040          ADD      r0,r0,r0,LSL #1
0004a4  4af5              LDR      r2,|L1.2172|
0004a6  eb0200c0          ADD      r0,r2,r0,LSL #3
0004aa  8081              STRH     r1,[r0,#4]
;;;158    					s[index+4].echo++;
0004ac  48f2              LDR      r0,|L1.2168|
0004ae  8800              LDRH     r0,[r0,#0]  ; index
0004b0  1d00              ADDS     r0,r0,#4
0004b2  eb000040          ADD      r0,r0,r0,LSL #1
0004b6  4611              MOV      r1,r2
0004b8  eb0100c0          ADD      r0,r1,r0,LSL #3
0004bc  7c00              LDRB     r0,[r0,#0x10]
0004be  1c40              ADDS     r0,r0,#1
0004c0  b2c1              UXTB     r1,r0
0004c2  48ed              LDR      r0,|L1.2168|
0004c4  8800              LDRH     r0,[r0,#0]  ; index
0004c6  1d00              ADDS     r0,r0,#4
0004c8  eb000040          ADD      r0,r0,r0,LSL #1
0004cc  eb0200c0          ADD      r0,r2,r0,LSL #3
0004d0  7401              STRB     r1,[r0,#0x10]
;;;159    					fire1 = 1;						//置为点火标志
0004d2  2001              MOVS     r0,#1
0004d4  49e6              LDR      r1,|L1.2160|
0004d6  7008              STRB     r0,[r1,#0]
                  |L1.1240|
;;;160    				}
;;;161    			}
;;;162    			if(0 == fire2)
0004d8  48e9              LDR      r0,|L1.2176|
0004da  7800              LDRB     r0,[r0,#0]  ; fire2
0004dc  bb30              CBNZ     r0,|L1.1324|
;;;163    			{
;;;164    				if(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_2)==1) //Group_2: 8,9,10,11
0004de  2104              MOVS     r1,#4
0004e0  48e4              LDR      r0,|L1.2164|
0004e2  f7fffffe          BL       GPIO_ReadInputDataBit
0004e6  2801              CMP      r0,#1
0004e8  d120              BNE      |L1.1324|
;;;165    				{
;;;166    					s[index+8].beggin = TIM2->CNT;	//如果高电平触发，开始计时
0004ea  0780              LSLS     r0,r0,#30
0004ec  8c81              LDRH     r1,[r0,#0x24]
0004ee  48e2              LDR      r0,|L1.2168|
0004f0  8800              LDRH     r0,[r0,#0]  ; index
0004f2  3008              ADDS     r0,r0,#8
0004f4  eb000040          ADD      r0,r0,r0,LSL #1
0004f8  4ae0              LDR      r2,|L1.2172|
0004fa  eb0200c0          ADD      r0,r2,r0,LSL #3
0004fe  8081              STRH     r1,[r0,#4]
;;;167    					s[index+8].echo++;
000500  48dd              LDR      r0,|L1.2168|
000502  8800              LDRH     r0,[r0,#0]  ; index
000504  3008              ADDS     r0,r0,#8
000506  eb000040          ADD      r0,r0,r0,LSL #1
00050a  4611              MOV      r1,r2
00050c  eb0100c0          ADD      r0,r1,r0,LSL #3
000510  7c00              LDRB     r0,[r0,#0x10]
000512  1c40              ADDS     r0,r0,#1
000514  b2c1              UXTB     r1,r0
000516  48d8              LDR      r0,|L1.2168|
000518  8800              LDRH     r0,[r0,#0]  ; index
00051a  3008              ADDS     r0,r0,#8
00051c  eb000040          ADD      r0,r0,r0,LSL #1
000520  eb0200c0          ADD      r0,r2,r0,LSL #3
000524  7401              STRB     r1,[r0,#0x10]
;;;168    					fire2 = 1;						//置为点火标志
000526  2001              MOVS     r0,#1
000528  49d5              LDR      r1,|L1.2176|
00052a  7008              STRB     r0,[r1,#0]
                  |L1.1324|
;;;169    				}
;;;170    			}
;;;171    			if(0 == fire3)
00052c  48d5              LDR      r0,|L1.2180|
00052e  7800              LDRB     r0,[r0,#0]  ; fire3
000530  bb30              CBNZ     r0,|L1.1408|
;;;172    			{
;;;173    				if(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_3)==1) //Group_3: 12,13,14,15
000532  2108              MOVS     r1,#8
000534  48cf              LDR      r0,|L1.2164|
000536  f7fffffe          BL       GPIO_ReadInputDataBit
00053a  2801              CMP      r0,#1
00053c  d120              BNE      |L1.1408|
;;;174    				{
;;;175    					s[index+12].beggin = TIM2->CNT;	//如果高电平触发，开始计时
00053e  0780              LSLS     r0,r0,#30
000540  8c81              LDRH     r1,[r0,#0x24]
000542  48cd              LDR      r0,|L1.2168|
000544  8800              LDRH     r0,[r0,#0]  ; index
000546  300c              ADDS     r0,r0,#0xc
000548  eb000040          ADD      r0,r0,r0,LSL #1
00054c  4acb              LDR      r2,|L1.2172|
00054e  eb0200c0          ADD      r0,r2,r0,LSL #3
000552  8081              STRH     r1,[r0,#4]
;;;176    					s[index+12].echo++;
000554  48c8              LDR      r0,|L1.2168|
000556  8800              LDRH     r0,[r0,#0]  ; index
000558  300c              ADDS     r0,r0,#0xc
00055a  eb000040          ADD      r0,r0,r0,LSL #1
00055e  4611              MOV      r1,r2
000560  eb0100c0          ADD      r0,r1,r0,LSL #3
000564  7c00              LDRB     r0,[r0,#0x10]
000566  1c40              ADDS     r0,r0,#1
000568  b2c1              UXTB     r1,r0
00056a  48c3              LDR      r0,|L1.2168|
00056c  8800              LDRH     r0,[r0,#0]  ; index
00056e  300c              ADDS     r0,r0,#0xc
000570  eb000040          ADD      r0,r0,r0,LSL #1
000574  eb0200c0          ADD      r0,r2,r0,LSL #3
000578  7401              STRB     r1,[r0,#0x10]
;;;177    					fire3 = 1;						//置为点火标志
00057a  2001              MOVS     r0,#1
00057c  49c1              LDR      r1,|L1.2180|
00057e  7008              STRB     r0,[r1,#0]
                  |L1.1408|
;;;178    				}
;;;179    			}
;;;180    			if(TIM2->CNT > 500)
000580  f04f4080          MOV      r0,#0x40000000
000584  8c80              LDRH     r0,[r0,#0x24]
000586  f5b07ffa          CMP      r0,#0x1f4
00058a  dd02              BLE      |L1.1426|
;;;181    			{
;;;182    				allfire = 1;          				//如果超过500us（85mm），不再等待
00058c  2001              MOVS     r0,#1
00058e  49be              LDR      r1,|L1.2184|
000590  7008              STRB     r0,[r1,#0]
                  |L1.1426|
000592  48bd              LDR      r0,|L1.2184|
000594  7800              LDRB     r0,[r0,#0]            ;141  ; allfire
000596  2800              CMP      r0,#0                 ;141
000598  f43faf12          BEQ      |L1.960|
;;;183    			}
;;;184    		}
;;;185    
;;;186    		while(0 == allend)		 					//记录时间
00059c  e0ad              B        |L1.1786|
                  |L1.1438|
;;;187    		{
;;;188    			if(0 == end0)
00059e  48bb              LDR      r0,|L1.2188|
0005a0  7800              LDRB     r0,[r0,#0]  ; end0
0005a2  bb10              CBNZ     r0,|L1.1514|
;;;189    			{
;;;190    				if(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_0)==0) //Group_0: 0,1,2,3
0005a4  2101              MOVS     r1,#1
0005a6  48b3              LDR      r0,|L1.2164|
0005a8  f7fffffe          BL       GPIO_ReadInputDataBit
0005ac  b9e8              CBNZ     r0,|L1.1514|
;;;191    				{
;;;192    					s[index].end = TIM2->CNT;		//如果高电平触发，开始计时
0005ae  f04f4080          MOV      r0,#0x40000000
0005b2  8c80              LDRH     r0,[r0,#0x24]
0005b4  49b0              LDR      r1,|L1.2168|
0005b6  8809              LDRH     r1,[r1,#0]  ; index
0005b8  eb010141          ADD      r1,r1,r1,LSL #1
0005bc  4aaf              LDR      r2,|L1.2172|
0005be  eb0201c1          ADD      r1,r2,r1,LSL #3
0005c2  80c8              STRH     r0,[r1,#6]
;;;193    					s[index].echo++;
0005c4  48ac              LDR      r0,|L1.2168|
0005c6  8800              LDRH     r0,[r0,#0]  ; index
0005c8  eb000040          ADD      r0,r0,r0,LSL #1
0005cc  4611              MOV      r1,r2
0005ce  eb0100c0          ADD      r0,r1,r0,LSL #3
0005d2  7c00              LDRB     r0,[r0,#0x10]
0005d4  1c40              ADDS     r0,r0,#1
0005d6  49a8              LDR      r1,|L1.2168|
0005d8  8809              LDRH     r1,[r1,#0]  ; index
0005da  eb010141          ADD      r1,r1,r1,LSL #1
0005de  eb0201c1          ADD      r1,r2,r1,LSL #3
0005e2  7408              STRB     r0,[r1,#0x10]
;;;194    					end0 = 1;						//置为点火标志
0005e4  2001              MOVS     r0,#1
0005e6  49a9              LDR      r1,|L1.2188|
0005e8  7008              STRB     r0,[r1,#0]
                  |L1.1514|
;;;195    				//test();
;;;196    				}
;;;197    			}
;;;198    			if(0 == end1)
0005ea  48a9              LDR      r0,|L1.2192|
0005ec  7800              LDRB     r0,[r0,#0]  ; end1
0005ee  bb30              CBNZ     r0,|L1.1598|
;;;199    			{
;;;200    				if(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_1)==0) //Group_1: 4,5,6,7
0005f0  2102              MOVS     r1,#2
0005f2  48a0              LDR      r0,|L1.2164|
0005f4  f7fffffe          BL       GPIO_ReadInputDataBit
0005f8  bb08              CBNZ     r0,|L1.1598|
;;;201    				{
;;;202    					s[index+4].end = TIM2->CNT;	//如果高电平触发，开始计时
0005fa  f04f4080          MOV      r0,#0x40000000
0005fe  8c81              LDRH     r1,[r0,#0x24]
000600  489d              LDR      r0,|L1.2168|
000602  8800              LDRH     r0,[r0,#0]  ; index
000604  1d00              ADDS     r0,r0,#4
000606  eb000040          ADD      r0,r0,r0,LSL #1
00060a  4a9c              LDR      r2,|L1.2172|
00060c  eb0200c0          ADD      r0,r2,r0,LSL #3
000610  80c1              STRH     r1,[r0,#6]
;;;203    					s[index+4].echo++;
000612  4899              LDR      r0,|L1.2168|
000614  8800              LDRH     r0,[r0,#0]  ; index
000616  1d00              ADDS     r0,r0,#4
000618  eb000040          ADD      r0,r0,r0,LSL #1
00061c  4611              MOV      r1,r2
00061e  eb0100c0          ADD      r0,r1,r0,LSL #3
000622  7c00              LDRB     r0,[r0,#0x10]
000624  1c40              ADDS     r0,r0,#1
000626  b2c1              UXTB     r1,r0
000628  4893              LDR      r0,|L1.2168|
00062a  8800              LDRH     r0,[r0,#0]  ; index
00062c  1d00              ADDS     r0,r0,#4
00062e  eb000040          ADD      r0,r0,r0,LSL #1
000632  eb0200c0          ADD      r0,r2,r0,LSL #3
000636  7401              STRB     r1,[r0,#0x10]
;;;204    					end1 = 1;						//置为点火标志
000638  2001              MOVS     r0,#1
00063a  4995              LDR      r1,|L1.2192|
00063c  7008              STRB     r0,[r1,#0]
                  |L1.1598|
;;;205    				}
;;;206    			}
;;;207    			if(0 == end2)
00063e  4895              LDR      r0,|L1.2196|
000640  7800              LDRB     r0,[r0,#0]  ; end2
000642  bb30              CBNZ     r0,|L1.1682|
;;;208    			{
;;;209    				if(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_2)==0) //Group_2: 8,9,10,11
000644  2104              MOVS     r1,#4
000646  488b              LDR      r0,|L1.2164|
000648  f7fffffe          BL       GPIO_ReadInputDataBit
00064c  bb08              CBNZ     r0,|L1.1682|
;;;210    				{
;;;211    					s[index+8].end = TIM2->CNT;	//如果高电平触发，开始计时
00064e  f04f4080          MOV      r0,#0x40000000
000652  8c81              LDRH     r1,[r0,#0x24]
000654  4888              LDR      r0,|L1.2168|
000656  8800              LDRH     r0,[r0,#0]  ; index
000658  3008              ADDS     r0,r0,#8
00065a  eb000040          ADD      r0,r0,r0,LSL #1
00065e  4a87              LDR      r2,|L1.2172|
000660  eb0200c0          ADD      r0,r2,r0,LSL #3
000664  80c1              STRH     r1,[r0,#6]
;;;212    					s[index+8].echo++;
000666  4884              LDR      r0,|L1.2168|
000668  8800              LDRH     r0,[r0,#0]  ; index
00066a  3008              ADDS     r0,r0,#8
00066c  eb000040          ADD      r0,r0,r0,LSL #1
000670  4611              MOV      r1,r2
000672  eb0100c0          ADD      r0,r1,r0,LSL #3
000676  7c00              LDRB     r0,[r0,#0x10]
000678  1c40              ADDS     r0,r0,#1
00067a  b2c1              UXTB     r1,r0
00067c  487e              LDR      r0,|L1.2168|
00067e  8800              LDRH     r0,[r0,#0]  ; index
000680  3008              ADDS     r0,r0,#8
000682  eb000040          ADD      r0,r0,r0,LSL #1
000686  eb0200c0          ADD      r0,r2,r0,LSL #3
00068a  7401              STRB     r1,[r0,#0x10]
;;;213    					end2 = 1;						//置为点火标志
00068c  2001              MOVS     r0,#1
00068e  4981              LDR      r1,|L1.2196|
000690  7008              STRB     r0,[r1,#0]
                  |L1.1682|
;;;214    				}
;;;215    			}
;;;216    			if(0 == end3)
000692  4881              LDR      r0,|L1.2200|
000694  7800              LDRB     r0,[r0,#0]  ; end3
000696  bb30              CBNZ     r0,|L1.1766|
;;;217    			{
;;;218    				if(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_3)==0) //Group_2: 12,13,14,15
000698  2108              MOVS     r1,#8
00069a  4876              LDR      r0,|L1.2164|
00069c  f7fffffe          BL       GPIO_ReadInputDataBit
0006a0  bb08              CBNZ     r0,|L1.1766|
;;;219    				{
;;;220    					s[index+12].end = TIM2->CNT;	//如果高电平触发，开始计时
0006a2  f04f4080          MOV      r0,#0x40000000
0006a6  8c81              LDRH     r1,[r0,#0x24]
0006a8  4873              LDR      r0,|L1.2168|
0006aa  8800              LDRH     r0,[r0,#0]  ; index
0006ac  300c              ADDS     r0,r0,#0xc
0006ae  eb000040          ADD      r0,r0,r0,LSL #1
0006b2  4a72              LDR      r2,|L1.2172|
0006b4  eb0200c0          ADD      r0,r2,r0,LSL #3
0006b8  80c1              STRH     r1,[r0,#6]
;;;221    					s[index+12].echo++;
0006ba  486f              LDR      r0,|L1.2168|
0006bc  8800              LDRH     r0,[r0,#0]  ; index
0006be  300c              ADDS     r0,r0,#0xc
0006c0  eb000040          ADD      r0,r0,r0,LSL #1
0006c4  4611              MOV      r1,r2
0006c6  eb0100c0          ADD      r0,r1,r0,LSL #3
0006ca  7c00              LDRB     r0,[r0,#0x10]
0006cc  1c40              ADDS     r0,r0,#1
0006ce  b2c1              UXTB     r1,r0
0006d0  4869              LDR      r0,|L1.2168|
0006d2  8800              LDRH     r0,[r0,#0]  ; index
0006d4  300c              ADDS     r0,r0,#0xc
0006d6  eb000040          ADD      r0,r0,r0,LSL #1
0006da  eb0200c0          ADD      r0,r2,r0,LSL #3
0006de  7401              STRB     r1,[r0,#0x10]
;;;222    					end3 = 1;						//置为点火标志
0006e0  2001              MOVS     r0,#1
0006e2  496d              LDR      r1,|L1.2200|
0006e4  7008              STRB     r0,[r1,#0]
                  |L1.1766|
;;;223    				}
;;;224    			}
;;;225    			if(TIM2->CNT > 25000)
0006e6  f04f4080          MOV      r0,#0x40000000
0006ea  8c80              LDRH     r0,[r0,#0x24]
0006ec  f24611a8          MOV      r1,#0x61a8
0006f0  4288              CMP      r0,r1
0006f2  dd02              BLE      |L1.1786|
;;;226    			{
;;;227    				allend = 1;          			//如果超过25ms（4250mm），不再等待
0006f4  2001              MOVS     r0,#1
0006f6  4969              LDR      r1,|L1.2204|
0006f8  7008              STRB     r0,[r1,#0]
                  |L1.1786|
0006fa  4868              LDR      r0,|L1.2204|
0006fc  7800              LDRB     r0,[r0,#0]            ;186  ; allend
0006fe  2800              CMP      r0,#0                 ;186
000700  f43faf4d          BEQ      |L1.1438|
;;;228    			}
;;;229    		}
;;;230    
;;;231    //		delay_ms(25); 				 		//延时，降低噪声干扰 50*4=200ms 周期
;;;232    											//
;;;233    											//所以，提高稳定性出发点：探头干扰降低
;;;234    		TIM_Cmd(TIM2, DISABLE);
000704  2100              MOVS     r1,#0
000706  f04f4080          MOV      r0,#0x40000000
00070a  f7fffffe          BL       TIM_Cmd
;;;235    		if(index == 0)				  		//如果一帧数据结束，计算数据,复位标志位
00070e  485a              LDR      r0,|L1.2168|
000710  8800              LDRH     r0,[r0,#0]  ; index
000712  bbe8              CBNZ     r0,|L1.1936|
;;;236    		{
;;;237    			//USART_SendData(USART1,'P');		//请求手柄数据
;;;238    			for(i=0;i<16;i++)
000714  2600              MOVS     r6,#0
000716  e046              B        |L1.1958|
                  |L1.1816|
;;;239    			{
;;;240    				if(s[i].echo != 2)
000718  eb060046          ADD      r0,r6,r6,LSL #1
00071c  4957              LDR      r1,|L1.2172|
00071e  eb0100c0          ADD      r0,r1,r0,LSL #3
000722  7c00              LDRB     r0,[r0,#0x10]
000724  2802              CMP      r0,#2
000726  d008              BEQ      |L1.1850|
;;;241    				{
;;;242    					s[i].ctime = 25000;
000728  f24610a8          MOV      r0,#0x61a8
00072c  eb060146          ADD      r1,r6,r6,LSL #1
000730  4a52              LDR      r2,|L1.2172|
000732  eb0201c1          ADD      r1,r2,r1,LSL #3
000736  8048              STRH     r0,[r1,#2]
000738  e016              B        |L1.1896|
                  |L1.1850|
;;;243    				}
;;;244    				else
;;;245    				{
;;;246    					s[i].ctime = abs(s[i].beggin - s[i].end);
00073a  eb060146          ADD      r1,r6,r6,LSL #1
00073e  4a4f              LDR      r2,|L1.2172|
000740  eb0201c1          ADD      r1,r2,r1,LSL #3
000744  8889              LDRH     r1,[r1,#4]
000746  eb060246          ADD      r2,r6,r6,LSL #1
00074a  4b4c              LDR      r3,|L1.2172|
00074c  eb0302c2          ADD      r2,r3,r2,LSL #3
000750  88d2              LDRH     r2,[r2,#6]
000752  1a88              SUBS     r0,r1,r2
000754  d401              BMI      |L1.1882|
000756  4601              MOV      r1,r0
000758  e000              B        |L1.1884|
                  |L1.1882|
00075a  4241              RSBS     r1,r0,#0
                  |L1.1884|
00075c  eb060246          ADD      r2,r6,r6,LSL #1
000760  4b46              LDR      r3,|L1.2172|
000762  eb0302c2          ADD      r2,r3,r2,LSL #3
000766  8051              STRH     r1,[r2,#2]
                  |L1.1896|
;;;247    				}
;;;248    				s[i].dis = 0.17*s[i].ctime; //时间量转换为距离量
000768  eb060146          ADD      r1,r6,r6,LSL #1
00076c  4a43              LDR      r2,|L1.2172|
00076e  eb0201c1          ADD      r1,r2,r1,LSL #3
000772  8848              LDRH     r0,[r1,#2]
000774  f7fffffe          BL       __aeabi_ui2d
000778  4607              MOV      r7,r0
00077a  4a49              LDR      r2,|L1.2208|
00077c  4b49              LDR      r3,|L1.2212|
00077e  f7fffffe          BL       __aeabi_dmul
000782  4604              MOV      r4,r0
000784  f7fffffe          BL       __aeabi_d2uiz
000788  eb060146          ADD      r1,r6,r6,LSL #1
00078c  4a3b              LDR      r2,|L1.2172|
00078e  e000              B        |L1.1938|
                  |L1.1936|
000790  e336              B        |L1.3584|
                  |L1.1938|
000792  eb0201c1          ADD      r1,r2,r1,LSL #3
000796  8108              STRH     r0,[r1,#8]
;;;249    				s[i].echo = 0;
000798  2000              MOVS     r0,#0
00079a  eb060146          ADD      r1,r6,r6,LSL #1
00079e  eb0201c1          ADD      r1,r2,r1,LSL #3
0007a2  7408              STRB     r0,[r1,#0x10]
0007a4  1c76              ADDS     r6,r6,#1              ;238
                  |L1.1958|
0007a6  2e10              CMP      r6,#0x10              ;238
0007a8  dbb6              BLT      |L1.1816|
;;;250    				
;;;251    			}
;;;252    
;;;253    	
;;;254    //		 filter(s, 16, 2500, 3);								//滤波器
;;;255    		
;;;256    
;;;257    		 if(1 == RxCtl.updated)									//等待接受完一帧数据，计算下发指令
0007aa  483f              LDR      r0,|L1.2216|
0007ac  7c40              LDRB     r0,[r0,#0x11]  ; RxCtl
0007ae  2801              CMP      r0,#1
0007b0  d15a              BNE      |L1.2152|
;;;258    		 {
;;;259    		 	 //USART_ITConfig(USART1,USART_IT_RXNE,DISABLE);   	//关闭串口中断，为数据上锁
;;;260    			 RxCtl.updated = 0;
0007b2  2000              MOVS     r0,#0
0007b4  493c              LDR      r1,|L1.2216|
0007b6  7448              STRB     r0,[r1,#0x11]
;;;261    
;;;262    			 Ufstick = RxCtl.buffer[10] * 0x0005;           	//记录当前用户输入线速度
0007b8  4608              MOV      r0,r1
0007ba  f990000a          LDRSB    r0,[r0,#0xa]  ; RxCtl
0007be  eb000080          ADD      r0,r0,r0,LSL #2
0007c2  493a              LDR      r1,|L1.2220|
0007c4  8008              STRH     r0,[r1,#0]
;;;263    		  	 Urstick = RxCtl.buffer[11] * 0x0005;		    	//记录当前用户输入角速度
0007c6  4838              LDR      r0,|L1.2216|
0007c8  f990000b          LDRSB    r0,[r0,#0xb]  ; RxCtl
0007cc  eb000080          ADD      r0,r0,r0,LSL #2
0007d0  4937              LDR      r1,|L1.2224|
0007d2  8008              STRH     r0,[r1,#0]
;;;264    
;;;265    			 Urstick = Urstick/512.0*90.0;						//角速度量纲转换为 度/秒
0007d4  4608              MOV      r0,r1
0007d6  f9b00000          LDRSH    r0,[r0,#0]  ; Urstick
0007da  f7fffffe          BL       __aeabi_i2d
0007de  4604              MOV      r4,r0
0007e0  2200              MOVS     r2,#0
0007e2  f04f4381          MOV      r3,#0x40800000
0007e6  f7fffffe          BL       __aeabi_ddiv
0007ea  4681              MOV      r9,r0
0007ec  2200              MOVS     r2,#0
0007ee  4b31              LDR      r3,|L1.2228|
0007f0  f7fffffe          BL       __aeabi_dmul
0007f4  4607              MOV      r7,r0
0007f6  f7fffffe          BL       __aeabi_d2iz
0007fa  b200              SXTH     r0,r0
0007fc  492c              LDR      r1,|L1.2224|
0007fe  8008              STRH     r0,[r1,#0]
;;;266    			 Ufstick = Ufstick/512.0*650.0;						//线速度量纲转换为 mm/s
000800  482a              LDR      r0,|L1.2220|
000802  f9b00000          LDRSH    r0,[r0,#0]  ; Ufstick
000806  f7fffffe          BL       __aeabi_i2d
00080a  4681              MOV      r9,r0
00080c  2200              MOVS     r2,#0
00080e  f04f4381          MOV      r3,#0x40800000
000812  f7fffffe          BL       __aeabi_ddiv
000816  4604              MOV      r4,r0
000818  2200              MOVS     r2,#0
00081a  4b27              LDR      r3,|L1.2232|
00081c  f7fffffe          BL       __aeabi_dmul
000820  4607              MOV      r7,r0
000822  f7fffffe          BL       __aeabi_d2iz
000826  b200              SXTH     r0,r0
000828  4920              LDR      r1,|L1.2220|
00082a  8008              STRH     r0,[r1,#0]
;;;267    	
;;;268    			 //USART_ITConfig(USART1,USART_IT_RXNE,ENABLE);   	//开启串口中断，为数据解锁
;;;269    
;;;270    			
;;;271    			 if(fabs(Urstick)<=5 && fabs(Ufstick)<=10)						//速度为0，直接下发停止指令
00082c  4820              LDR      r0,|L1.2224|
00082e  f9b00000          LDRSH    r0,[r0,#0]  ; Urstick
000832  f7fffffe          BL       __aeabi_i2d
000836  f0214100          BIC      r1,r1,#0x80000000
00083a  4604              MOV      r4,r0
00083c  2200              MOVS     r2,#0
00083e  4b1f              LDR      r3,|L1.2236|
000840  f7fffffe          BL       __aeabi_cdcmple
000844  d840              BHI      |L1.2248|
000846  4819              LDR      r0,|L1.2220|
000848  f9b00000          LDRSH    r0,[r0,#0]  ; Ufstick
00084c  f7fffffe          BL       __aeabi_i2d
000850  f0214100          BIC      r1,r1,#0x80000000
000854  4604              MOV      r4,r0
000856  2200              MOVS     r2,#0
000858  4b19              LDR      r3,|L1.2240|
00085a  f7fffffe          BL       __aeabi_cdcmple
00085e  d833              BHI      |L1.2248|
;;;272    			 {
;;;273    				safe = 1;
000860  2001              MOVS     r0,#1
000862  4918              LDR      r1,|L1.2244|
000864  7008              STRB     r0,[r1,#0]
000866  e066              B        |L1.2358|
                  |L1.2152|
000868  e2bd              B        |L1.3558|
00086a  0000              DCW      0x0000
                  |L1.2156|
                          DCD      fire0
                  |L1.2160|
                          DCD      fire1
                  |L1.2164|
                          DCD      0x40010800
                  |L1.2168|
                          DCD      index
                  |L1.2172|
                          DCD      s
                  |L1.2176|
                          DCD      fire2
                  |L1.2180|
                          DCD      fire3
                  |L1.2184|
                          DCD      allfire
                  |L1.2188|
                          DCD      end0
                  |L1.2192|
                          DCD      end1
                  |L1.2196|
                          DCD      end2
                  |L1.2200|
                          DCD      end3
                  |L1.2204|
                          DCD      allend
                  |L1.2208|
                          DCD      0x5c28f5c3
                  |L1.2212|
                          DCD      0x3fc5c28f
                  |L1.2216|
                          DCD      RxCtl
                  |L1.2220|
                          DCD      Ufstick
                  |L1.2224|
                          DCD      Urstick
                  |L1.2228|
                          DCD      0x40568000
                  |L1.2232|
                          DCD      0x40845000
                  |L1.2236|
                          DCD      0x40140000
                  |L1.2240|
                          DCD      0x40240000
                  |L1.2244|
                          DCD      safe
                  |L1.2248|
;;;274    			 }
;;;275    			 else if(Ufstick <= 0)								//速度为负，判断后方是否安全
0008c8  48ff              LDR      r0,|L1.3272|
0008ca  f9b00000          LDRSH    r0,[r0,#0]  ; Ufstick
0008ce  2800              CMP      r0,#0
0008d0  dc14              BGT      |L1.2300|
;;;276    			 {
;;;277    			 	if(s[13].dis < danger || s[14].dis < danger)
0008d2  48fe              LDR      r0,|L1.3276|
0008d4  f8b00140          LDRH     r0,[r0,#0x140]
0008d8  f5b07f96          CMP      r0,#0x12c
0008dc  db05              BLT      |L1.2282|
0008de  48fb              LDR      r0,|L1.3276|
0008e0  f8b00158          LDRH     r0,[r0,#0x158]
0008e4  f5b07f96          CMP      r0,#0x12c
0008e8  da04              BGE      |L1.2292|
                  |L1.2282|
;;;278    				{
;;;279    					Ufstick = 0;
0008ea  2000              MOVS     r0,#0
0008ec  49f6              LDR      r1,|L1.3272|
0008ee  8008              STRH     r0,[r1,#0]
;;;280    					Urstick = 0;  							//如果倒车，判断后面危险性，小于安全距离停车
0008f0  49f7              LDR      r1,|L1.3280|
0008f2  8008              STRH     r0,[r1,#0]
                  |L1.2292|
;;;281    				}
;;;282    					safe = 1;										
0008f4  2001              MOVS     r0,#1
0008f6  49f7              LDR      r1,|L1.3284|
0008f8  7008              STRB     r0,[r1,#0]
0008fa  e01c              B        |L1.2358|
                  |L1.2300|
;;;283    			 }
;;;284    			 else
;;;285    			 {
;;;286    				/* if(s[15].dis > 9000) 						//检测楼梯，有楼梯，停车
;;;287    				 {
;;;288    				 	Ufstick = 0;
;;;289    					Urstick = 0;
;;;290    					safe = 1;
;;;291    				 }
;;;292    				 */
;;;293    			//	 else
;;;294    				 {
;;;295    				 	 safe = 1;
0008fc  2001              MOVS     r0,#1
0008fe  49f5              LDR      r1,|L1.3284|
000900  7008              STRB     r0,[r1,#0]
;;;296    					 udir = (Urstick+90)/15;					//计算当前用户行使方向（超声波坐标系）
000902  48f3              LDR      r0,|L1.3280|
000904  f9b00000          LDRSH    r0,[r0,#0]  ; Urstick
000908  305a              ADDS     r0,r0,#0x5a
00090a  210f              MOVS     r1,#0xf
00090c  fb90f0f1          SDIV     r0,r0,r1
000910  49f1              LDR      r1,|L1.3288|
000912  7008              STRB     r0,[r1,#0]
;;;297    					 
;;;298    																//判断用户输入是否安全
;;;299    					 for(i=0;i<13;i++)							//zhjf:前进指令0_12;后面预警13_14；15reserved
000914  2600              MOVS     r6,#0
000916  e00c              B        |L1.2354|
                  |L1.2328|
;;;300    					 {
;;;301    					  	if(s[i].dis < warn)
000918  eb060046          ADD      r0,r6,r6,LSL #1
00091c  49eb              LDR      r1,|L1.3276|
00091e  eb0100c0          ADD      r0,r1,r0,LSL #3
000922  8900              LDRH     r0,[r0,#8]
000924  f5b07ffa          CMP      r0,#0x1f4
000928  da02              BGE      |L1.2352|
;;;302    						{
;;;303    							safe = 0;
00092a  2000              MOVS     r0,#0
00092c  49e9              LDR      r1,|L1.3284|
00092e  7008              STRB     r0,[r1,#0]
                  |L1.2352|
000930  1c76              ADDS     r6,r6,#1              ;299
                  |L1.2354|
000932  2e0d              CMP      r6,#0xd               ;299
000934  dbf0              BLT      |L1.2328|
                  |L1.2358|
;;;304    						}
;;;305    					 }
;;;306    					 
;;;307    				 }
;;;308    			 }												//如果行驶方向安全，直接下发用户指令
;;;309    			if(safe)
000936  48e7              LDR      r0,|L1.3284|
000938  7800              LDRB     r0,[r0,#0]  ; safe
00093a  b150              CBZ      r0,|L1.2386|
;;;310    			{
;;;311    				Rstick = Urstick;
00093c  48e4              LDR      r0,|L1.3280|
00093e  f9b00000          LDRSH    r0,[r0,#0]  ; Urstick
000942  49e6              LDR      r1,|L1.3292|
000944  8008              STRH     r0,[r1,#0]
;;;312    				Fstick = Ufstick;
000946  48e0              LDR      r0,|L1.3272|
000948  f9b00000          LDRSH    r0,[r0,#0]  ; Ufstick
00094c  49e4              LDR      r1,|L1.3296|
00094e  8008              STRH     r0,[r1,#0]
000950  e24e              B        |L1.3568|
                  |L1.2386|
;;;313    			}												//否则，降低运动速度，自主避障&过门
;;;314    			else											//用户输入只用来指示行使方向权重，即优选用户就近方向行使
;;;315    			{
;;;316    				if(Ufstick != 0)
000952  48dd              LDR      r0,|L1.3272|
000954  8800              LDRH     r0,[r0,#0]  ; Ufstick
000956  b3e8              CBZ      r0,|L1.2516|
;;;317    				{
;;;318    					int8_t n,cnt;
;;;319    					float X,Y,temp;
;;;320    					cnt = 0;
000958  f04f0800          MOV      r8,#0
;;;321    					X = 0;		  //笛卡尔坐标系
00095c  46c2              MOV      r10,r8
;;;322    					Y = 0;
00095e  46c3              MOV      r11,r8
;;;323    					for(n=0;n<13;n++)
000960  2700              MOVS     r7,#0
000962  e118              B        |L1.2966|
                  |L1.2404|
;;;324    					{
;;;325    						if(s[n].dis<warn && s[n].dis>danger)
000964  eb070047          ADD      r0,r7,r7,LSL #1
000968  49d8              LDR      r1,|L1.3276|
00096a  eb0100c0          ADD      r0,r1,r0,LSL #3
00096e  8900              LDRH     r0,[r0,#8]
000970  f5b07ffa          CMP      r0,#0x1f4
000974  da7e              BGE      |L1.2676|
000976  eb070047          ADD      r0,r7,r7,LSL #1
00097a  eb0100c0          ADD      r0,r1,r0,LSL #3
00097e  8900              LDRH     r0,[r0,#8]
000980  f5b07f96          CMP      r0,#0x12c
000984  dd76              BLE      |L1.2676|
;;;326    						{
;;;327    							//矢量模型：(（500-d)/200)^2 * cos() *650
;;;328    							X += ((warn-s[i].dis)/(warn - danger)) * ((warn-s[i].dis)/(warn-danger)) * cos((s[i].theta - 90)/180*PI) * MaxSpeed;
000986  eb060046          ADD      r0,r6,r6,LSL #1
00098a  eb0100c0          ADD      r0,r1,r0,LSL #3
00098e  f9b00012          LDRSH    r0,[r0,#0x12]
000992  385a              SUBS     r0,r0,#0x5a
000994  21b4              MOVS     r1,#0xb4
000996  fb90f0f1          SDIV     r0,r0,r1
00099a  9001              STR      r0,[sp,#4]
00099c  f7fffffe          BL       __aeabi_i2d
0009a0  4604              MOV      r4,r0
0009a2  4ad0              LDR      r2,|L1.3300|
0009a4  4bd0              LDR      r3,|L1.3304|
0009a6  f7fffffe          BL       __aeabi_dmul
0009aa  e9cd0102          STRD     r0,r1,[sp,#8]
0009ae  f7fffffe          BL       ||cos||
0009b2  e9cd0106          STRD     r0,r1,[sp,#0x18]
0009b6  eb060046          ADD      r0,r6,r6,LSL #1
0009ba  49c4              LDR      r1,|L1.3276|
0009bc  eb0100c0          ADD      r0,r1,r0,LSL #3
0009c0  8900              LDRH     r0,[r0,#8]
0009c2  f5c070fa          RSB      r0,r0,#0x1f4
0009c6  21c8              MOVS     r1,#0xc8
0009c8  fb90f0f1          SDIV     r0,r0,r1
0009cc  fb00f400          MUL      r4,r0,r0
0009d0  4620              MOV      r0,r4
0009d2  e000              B        |L1.2518|
                  |L1.2516|
0009d4  e1fc              B        |L1.3536|
                  |L1.2518|
0009d6  f7fffffe          BL       __aeabi_i2d
0009da  e9cd0104          STRD     r0,r1,[sp,#0x10]
0009de  e9dd2306          LDRD     r2,r3,[sp,#0x18]
0009e2  f7fffffe          BL       __aeabi_dmul
0009e6  2200              MOVS     r2,#0
0009e8  4bc0              LDR      r3,|L1.3308|
0009ea  e9cd0108          STRD     r0,r1,[sp,#0x20]
0009ee  f7fffffe          BL       __aeabi_dmul
0009f2  e9cd010c          STRD     r0,r1,[sp,#0x30]
0009f6  4650              MOV      r0,r10
0009f8  f7fffffe          BL       __aeabi_f2d
0009fc  e9cd010a          STRD     r0,r1,[sp,#0x28]
000a00  e9dd230c          LDRD     r2,r3,[sp,#0x30]
000a04  f7fffffe          BL       __aeabi_dadd
000a08  e9cd010e          STRD     r0,r1,[sp,#0x38]
000a0c  f7fffffe          BL       __aeabi_d2f
000a10  4682              MOV      r10,r0
;;;329    							Y += ((warn-s[i].dis)/(warn - danger)) * ((warn-s[i].dis)/(warn - danger)) * sin((s[i].theta - 90)/180*PI) * MaxSpeed;
000a12  eb060046          ADD      r0,r6,r6,LSL #1
000a16  49ad              LDR      r1,|L1.3276|
000a18  eb0100c0          ADD      r0,r1,r0,LSL #3
000a1c  f9b00012          LDRSH    r0,[r0,#0x12]
000a20  385a              SUBS     r0,r0,#0x5a
000a22  21b4              MOVS     r1,#0xb4
000a24  fb90f0f1          SDIV     r0,r0,r1
000a28  9001              STR      r0,[sp,#4]
000a2a  f7fffffe          BL       __aeabi_i2d
000a2e  4604              MOV      r4,r0
000a30  4aac              LDR      r2,|L1.3300|
000a32  4bad              LDR      r3,|L1.3304|
000a34  f7fffffe          BL       __aeabi_dmul
000a38  e9cd0102          STRD     r0,r1,[sp,#8]
000a3c  f7fffffe          BL       ||sin||
000a40  e9cd0106          STRD     r0,r1,[sp,#0x18]
000a44  eb060046          ADD      r0,r6,r6,LSL #1
000a48  49a0              LDR      r1,|L1.3276|
000a4a  eb0100c0          ADD      r0,r1,r0,LSL #3
000a4e  8900              LDRH     r0,[r0,#8]
000a50  f5c070fa          RSB      r0,r0,#0x1f4
000a54  21c8              MOVS     r1,#0xc8
000a56  fb90f0f1          SDIV     r0,r0,r1
000a5a  fb00f400          MUL      r4,r0,r0
000a5e  4620              MOV      r0,r4
000a60  f7fffffe          BL       __aeabi_i2d
000a64  e9cd0104          STRD     r0,r1,[sp,#0x10]
000a68  e9dd2306          LDRD     r2,r3,[sp,#0x18]
000a6c  f7fffffe          BL       __aeabi_dmul
000a70  2200              MOVS     r2,#0
000a72  e000              B        |L1.2678|
                  |L1.2676|
000a74  e019              B        |L1.2730|
                  |L1.2678|
000a76  4b9d              LDR      r3,|L1.3308|
000a78  e9cd0108          STRD     r0,r1,[sp,#0x20]
000a7c  f7fffffe          BL       __aeabi_dmul
000a80  e9cd010c          STRD     r0,r1,[sp,#0x30]
000a84  4658              MOV      r0,r11
000a86  f7fffffe          BL       __aeabi_f2d
000a8a  e9cd010a          STRD     r0,r1,[sp,#0x28]
000a8e  e9dd230c          LDRD     r2,r3,[sp,#0x30]
000a92  f7fffffe          BL       __aeabi_dadd
000a96  e9cd010e          STRD     r0,r1,[sp,#0x38]
000a9a  f7fffffe          BL       __aeabi_d2f
000a9e  4683              MOV      r11,r0
;;;330    							cnt++;
000aa0  f1080001          ADD      r0,r8,#1
000aa4  fa4ff880          SXTB     r8,r0
000aa8  e073              B        |L1.2962|
                  |L1.2730|
;;;331    						}
;;;332    						else if(s[n].dis < danger)
000aaa  eb070047          ADD      r0,r7,r7,LSL #1
000aae  4987              LDR      r1,|L1.3276|
000ab0  eb0100c0          ADD      r0,r1,r0,LSL #3
000ab4  8900              LDRH     r0,[r0,#8]
000ab6  f5b07f96          CMP      r0,#0x12c
000aba  da60              BGE      |L1.2942|
;;;333    						{
;;;334    							X += cos((s[i].theta - 90)/180*PI) * neginf;
000abc  eb060046          ADD      r0,r6,r6,LSL #1
000ac0  eb0100c0          ADD      r0,r1,r0,LSL #3
000ac4  f9b00012          LDRSH    r0,[r0,#0x12]
000ac8  385a              SUBS     r0,r0,#0x5a
000aca  21b4              MOVS     r1,#0xb4
000acc  fb90f4f1          SDIV     r4,r0,r1
000ad0  4620              MOV      r0,r4
000ad2  f7fffffe          BL       __aeabi_i2d
000ad6  4a83              LDR      r2,|L1.3300|
000ad8  4b83              LDR      r3,|L1.3304|
000ada  e9cd0104          STRD     r0,r1,[sp,#0x10]
000ade  e000              B        |L1.2786|
                  |L1.2784|
000ae0  e193              B        |L1.3594|
                  |L1.2786|
000ae2  f7fffffe          BL       __aeabi_dmul
000ae6  e9cd0106          STRD     r0,r1,[sp,#0x18]
000aea  f7fffffe          BL       ||cos||
000aee  2200              MOVS     r2,#0
000af0  4b7f              LDR      r3,|L1.3312|
000af2  e9cd0108          STRD     r0,r1,[sp,#0x20]
000af6  f7fffffe          BL       __aeabi_dmul
000afa  e9cd010c          STRD     r0,r1,[sp,#0x30]
000afe  4650              MOV      r0,r10
000b00  f7fffffe          BL       __aeabi_f2d
000b04  e9cd010a          STRD     r0,r1,[sp,#0x28]
000b08  e9dd230c          LDRD     r2,r3,[sp,#0x30]
000b0c  f7fffffe          BL       __aeabi_dadd
000b10  e9cd010e          STRD     r0,r1,[sp,#0x38]
000b14  f7fffffe          BL       __aeabi_d2f
000b18  4682              MOV      r10,r0
;;;335    							Y += sin((s[i].theta - 90)/180*PI) * neginf;
000b1a  eb060046          ADD      r0,r6,r6,LSL #1
000b1e  496b              LDR      r1,|L1.3276|
000b20  eb0100c0          ADD      r0,r1,r0,LSL #3
000b24  f9b00012          LDRSH    r0,[r0,#0x12]
000b28  385a              SUBS     r0,r0,#0x5a
000b2a  21b4              MOVS     r1,#0xb4
000b2c  fb90f0f1          SDIV     r0,r0,r1
000b30  9005              STR      r0,[sp,#0x14]
000b32  f7fffffe          BL       __aeabi_i2d
000b36  4604              MOV      r4,r0
000b38  4a6a              LDR      r2,|L1.3300|
000b3a  4b6b              LDR      r3,|L1.3304|
000b3c  f7fffffe          BL       __aeabi_dmul
000b40  e9cd0106          STRD     r0,r1,[sp,#0x18]
000b44  f7fffffe          BL       ||sin||
000b48  2200              MOVS     r2,#0
000b4a  4b69              LDR      r3,|L1.3312|
000b4c  e9cd0108          STRD     r0,r1,[sp,#0x20]
000b50  f7fffffe          BL       __aeabi_dmul
000b54  e9cd010c          STRD     r0,r1,[sp,#0x30]
000b58  4658              MOV      r0,r11
000b5a  f7fffffe          BL       __aeabi_f2d
000b5e  e9cd010a          STRD     r0,r1,[sp,#0x28]
000b62  e9dd230c          LDRD     r2,r3,[sp,#0x30]
000b66  f7fffffe          BL       __aeabi_dadd
000b6a  e9cd010e          STRD     r0,r1,[sp,#0x38]
000b6e  f7fffffe          BL       __aeabi_d2f
000b72  4683              MOV      r11,r0
;;;336    							cnt++;
000b74  f1080001          ADD      r0,r8,#1
000b78  fa4ff880          SXTB     r8,r0
000b7c  e009              B        |L1.2962|
                  |L1.2942|
;;;337    						}
;;;338    						else
;;;339    						{
;;;340    							X += 0;
000b7e  2100              MOVS     r1,#0
000b80  4650              MOV      r0,r10
000b82  f7fffffe          BL       __aeabi_fadd
000b86  4682              MOV      r10,r0
;;;341    							Y += 0;
000b88  2100              MOVS     r1,#0
000b8a  4658              MOV      r0,r11
000b8c  f7fffffe          BL       __aeabi_fadd
000b90  4683              MOV      r11,r0
                  |L1.2962|
000b92  1c78              ADDS     r0,r7,#1              ;323
000b94  b247              SXTB     r7,r0                 ;323
                  |L1.2966|
000b96  2f0d              CMP      r7,#0xd               ;323
000b98  f6ffaee4          BLT      |L1.2404|
;;;342    						}
;;;343    						
;;;344    					}
;;;345    					X =X/cnt*Kp + Ufstick * cos((Urstick + 90)/180*PI)*(1-Kp);
000b9c  484c              LDR      r0,|L1.3280|
000b9e  f9b00000          LDRSH    r0,[r0,#0]  ; Urstick
000ba2  305a              ADDS     r0,r0,#0x5a
000ba4  21b4              MOVS     r1,#0xb4
000ba6  fb90f0f1          SDIV     r0,r0,r1
000baa  9001              STR      r0,[sp,#4]
000bac  f7fffffe          BL       __aeabi_i2d
000bb0  4604              MOV      r4,r0
000bb2  4a4c              LDR      r2,|L1.3300|
000bb4  4b4c              LDR      r3,|L1.3304|
000bb6  f7fffffe          BL       __aeabi_dmul
000bba  e9cd0102          STRD     r0,r1,[sp,#8]
000bbe  f7fffffe          BL       ||cos||
000bc2  e9cd0106          STRD     r0,r1,[sp,#0x18]
000bc6  4840              LDR      r0,|L1.3272|
000bc8  f9b00000          LDRSH    r0,[r0,#0]  ; Ufstick
000bcc  f7fffffe          BL       __aeabi_i2d
000bd0  e9cd0104          STRD     r0,r1,[sp,#0x10]
000bd4  e9dd2306          LDRD     r2,r3,[sp,#0x18]
000bd8  f7fffffe          BL       __aeabi_dmul
000bdc  2200              MOVS     r2,#0
000bde  4b45              LDR      r3,|L1.3316|
000be0  e9cd0108          STRD     r0,r1,[sp,#0x20]
000be4  f7fffffe          BL       __aeabi_dmul
000be8  e9cd010c          STRD     r0,r1,[sp,#0x30]
000bec  4640              MOV      r0,r8
000bee  f7fffffe          BL       __aeabi_i2f
000bf2  4601              MOV      r1,r0
000bf4  9008              STR      r0,[sp,#0x20]
000bf6  4650              MOV      r0,r10
000bf8  f7fffffe          BL       __aeabi_fdiv
000bfc  9009              STR      r0,[sp,#0x24]
000bfe  f7fffffe          BL       __aeabi_f2d
000c02  4604              MOV      r4,r0
000c04  2200              MOVS     r2,#0
000c06  4b3b              LDR      r3,|L1.3316|
000c08  f7fffffe          BL       __aeabi_dmul
000c0c  e9cd010a          STRD     r0,r1,[sp,#0x28]
000c10  e9dd230c          LDRD     r2,r3,[sp,#0x30]
000c14  f7fffffe          BL       __aeabi_dadd
000c18  e9cd010e          STRD     r0,r1,[sp,#0x38]
000c1c  f7fffffe          BL       __aeabi_d2f
000c20  4682              MOV      r10,r0
;;;346    					Y =Y/cnt*Kp + Ufstick * sin((Urstick + 90)/180*PI)*(1-Kp);
000c22  482b              LDR      r0,|L1.3280|
000c24  f9b00000          LDRSH    r0,[r0,#0]  ; Urstick
000c28  305a              ADDS     r0,r0,#0x5a
000c2a  21b4              MOVS     r1,#0xb4
000c2c  fb90f0f1          SDIV     r0,r0,r1
000c30  9001              STR      r0,[sp,#4]
000c32  f7fffffe          BL       __aeabi_i2d
000c36  4a2b              LDR      r2,|L1.3300|
000c38  4b2b              LDR      r3,|L1.3304|
000c3a  e9cd0102          STRD     r0,r1,[sp,#8]
000c3e  f7fffffe          BL       __aeabi_dmul
000c42  e9cd0104          STRD     r0,r1,[sp,#0x10]
000c46  f7fffffe          BL       ||sin||
000c4a  e9cd0108          STRD     r0,r1,[sp,#0x20]
000c4e  481e              LDR      r0,|L1.3272|
000c50  f9b00000          LDRSH    r0,[r0,#0]  ; Ufstick
000c54  f7fffffe          BL       __aeabi_i2d
000c58  e9cd0106          STRD     r0,r1,[sp,#0x18]
000c5c  e9dd2308          LDRD     r2,r3,[sp,#0x20]
000c60  f7fffffe          BL       __aeabi_dmul
000c64  4604              MOV      r4,r0
000c66  2200              MOVS     r2,#0
000c68  4b22              LDR      r3,|L1.3316|
000c6a  f7fffffe          BL       __aeabi_dmul
000c6e  e9cd010c          STRD     r0,r1,[sp,#0x30]
000c72  4640              MOV      r0,r8
000c74  f7fffffe          BL       __aeabi_i2f
000c78  4605              MOV      r5,r0
000c7a  4601              MOV      r1,r0
000c7c  4658              MOV      r0,r11
000c7e  f7fffffe          BL       __aeabi_fdiv
000c82  4604              MOV      r4,r0
000c84  f7fffffe          BL       __aeabi_f2d
000c88  2200              MOVS     r2,#0
000c8a  4b1a              LDR      r3,|L1.3316|
000c8c  e9cd0108          STRD     r0,r1,[sp,#0x20]
000c90  f7fffffe          BL       __aeabi_dmul
000c94  e9cd010a          STRD     r0,r1,[sp,#0x28]
000c98  e9dd230c          LDRD     r2,r3,[sp,#0x30]
000c9c  f7fffffe          BL       __aeabi_dadd
000ca0  e9cd010e          STRD     r0,r1,[sp,#0x38]
000ca4  f7fffffe          BL       __aeabi_d2f
000ca8  4683              MOV      r11,r0
;;;347    					
;;;348    					//temp = X;
;;;349    					//X = Y;
;;;350    					//Y = temp;
;;;351    					
;;;352    					temp = sqrt(X*X + Y*Y);
000caa  4659              MOV      r1,r11
000cac  4658              MOV      r0,r11
000cae  f7fffffe          BL       __aeabi_fmul
000cb2  4651              MOV      r1,r10
000cb4  900c              STR      r0,[sp,#0x30]
000cb6  4650              MOV      r0,r10
000cb8  f7fffffe          BL       __aeabi_fmul
000cbc  900b              STR      r0,[sp,#0x2c]
000cbe  990c              LDR      r1,[sp,#0x30]
000cc0  f7fffffe          BL       __aeabi_fadd
000cc4  900d              STR      r0,[sp,#0x34]
000cc6  e017              B        |L1.3320|
                  |L1.3272|
                          DCD      Ufstick
                  |L1.3276|
                          DCD      s
                  |L1.3280|
                          DCD      Urstick
                  |L1.3284|
                          DCD      safe
                  |L1.3288|
                          DCD      udir
                  |L1.3292|
                          DCD      Rstick
                  |L1.3296|
                          DCD      Fstick
                  |L1.3300|
                          DCD      0x5a7ed197
                  |L1.3304|
                          DCD      0x400921fb
                  |L1.3308|
                          DCD      0x4082c000
                  |L1.3312|
                          DCD      0x408f4000
                  |L1.3316|
                          DCD      0x3fe00000
                  |L1.3320|
000cf8  f7fffffe          BL       __aeabi_f2d
000cfc  e9cd010e          STRD     r0,r1,[sp,#0x38]
000d00  f7fffffe          BL       sqrt
000d04  4604              MOV      r4,r0
000d06  f7fffffe          BL       __aeabi_d2f
000d0a  4681              MOV      r9,r0
;;;353                        Ufstick = temp;
000d0c  4648              MOV      r0,r9
000d0e  f7fffffe          BL       __aeabi_f2iz
000d12  b200              SXTH     r0,r0
000d14  49ff              LDR      r1,|L1.4372|
000d16  8008              STRH     r0,[r1,#0]
;;;354    					Urstick = asin(Y/temp)/PI * 180;
000d18  4649              MOV      r1,r9
000d1a  4658              MOV      r0,r11
000d1c  f7fffffe          BL       __aeabi_fdiv
000d20  9009              STR      r0,[sp,#0x24]
000d22  f7fffffe          BL       __aeabi_f2d
000d26  4604              MOV      r4,r0
000d28  f7fffffe          BL       asin
000d2c  4afa              LDR      r2,|L1.4376|
000d2e  4bfb              LDR      r3,|L1.4380|
000d30  e9cd010a          STRD     r0,r1,[sp,#0x28]
000d34  f7fffffe          BL       __aeabi_ddiv
000d38  2200              MOVS     r2,#0
000d3a  4bf9              LDR      r3,|L1.4384|
000d3c  e9cd010c          STRD     r0,r1,[sp,#0x30]
000d40  f7fffffe          BL       __aeabi_dmul
000d44  e9cd010e          STRD     r0,r1,[sp,#0x38]
000d48  f7fffffe          BL       __aeabi_d2iz
000d4c  b200              SXTH     r0,r0
000d4e  49f5              LDR      r1,|L1.4388|
000d50  8008              STRH     r0,[r1,#0]
;;;355    
;;;356    					if(X>=0 && Y>=0)
000d52  2100              MOVS     r1,#0
000d54  4650              MOV      r0,r10
000d56  f7fffffe          BL       __aeabi_cfrcmple
000d5a  d80b              BHI      |L1.3444|
000d5c  2100              MOVS     r1,#0
000d5e  4658              MOV      r0,r11
000d60  f7fffffe          BL       __aeabi_cfrcmple
000d64  d806              BHI      |L1.3444|
;;;357    					{
;;;358    						Urstick =Urstick - 90;
000d66  48ef              LDR      r0,|L1.4388|
000d68  8800              LDRH     r0,[r0,#0]  ; Urstick
000d6a  385a              SUBS     r0,r0,#0x5a
000d6c  b200              SXTH     r0,r0
000d6e  49ed              LDR      r1,|L1.4388|
000d70  8008              STRH     r0,[r1,#0]
000d72  e02c              B        |L1.3534|
                  |L1.3444|
;;;359    					}
;;;360    					else if(X>=0 && Y<0)
000d74  2100              MOVS     r1,#0
000d76  4650              MOV      r0,r10
000d78  f7fffffe          BL       __aeabi_cfrcmple
000d7c  d809              BHI      |L1.3474|
000d7e  2100              MOVS     r1,#0
000d80  4658              MOV      r0,r11
000d82  f7fffffe          BL       __aeabi_cfcmple
000d86  d204              BCS      |L1.3474|
;;;361    					{
;;;362    						Urstick =-90;
000d88  f06f0059          MVN      r0,#0x59
000d8c  49e5              LDR      r1,|L1.4388|
000d8e  8008              STRH     r0,[r1,#0]
000d90  e01d              B        |L1.3534|
                  |L1.3474|
;;;363    					}
;;;364    					else if(Y>=0 && X<0)
000d92  2100              MOVS     r1,#0
000d94  4658              MOV      r0,r11
000d96  f7fffffe          BL       __aeabi_cfrcmple
000d9a  d80b              BHI      |L1.3508|
000d9c  2100              MOVS     r1,#0
000d9e  4650              MOV      r0,r10
000da0  f7fffffe          BL       __aeabi_cfcmple
000da4  d206              BCS      |L1.3508|
;;;365    					{
;;;366    						Urstick += 90;
000da6  48df              LDR      r0,|L1.4388|
000da8  8800              LDRH     r0,[r0,#0]  ; Urstick
000daa  305a              ADDS     r0,r0,#0x5a
000dac  b200              SXTH     r0,r0
000dae  49dd              LDR      r1,|L1.4388|
000db0  8008              STRH     r0,[r1,#0]
000db2  e00c              B        |L1.3534|
                  |L1.3508|
;;;367    					}
;;;368    					else if (Y<0 && X<0)
000db4  2100              MOVS     r1,#0
000db6  4658              MOV      r0,r11
000db8  f7fffffe          BL       __aeabi_cfcmple
000dbc  d207              BCS      |L1.3534|
000dbe  2100              MOVS     r1,#0
000dc0  4650              MOV      r0,r10
000dc2  f7fffffe          BL       __aeabi_cfcmple
000dc6  d202              BCS      |L1.3534|
;;;369    					{
;;;370    						Urstick = 90;
000dc8  205a              MOVS     r0,#0x5a
000dca  49d6              LDR      r1,|L1.4388|
000dcc  8008              STRH     r0,[r1,#0]
                  |L1.3534|
;;;371    					}
;;;372    				
;;;373    				/****
;;;374    					int16_t sum,cnt,emergency;
;;;375    					sum = 0;
;;;376    					cnt = 0;
;;;377    					emergency = 15;
;;;378    	
;;;379    					Ufstick = Ufstick*0.6;						//速度降为用户输入的60%
;;;380    	
;;;381    	
;;;382    					for(i=0;i<13;i++)
;;;383    					{
;;;384    						if(s[1].dis > 300)
;;;385    						{
;;;386    							if(s[i].dis < danger)
;;;387    							{
;;;388    								sum = sum + s[i].theta;
;;;389    								cnt++;						
;;;390    							}
;;;391    						}
;;;392    						else
;;;393    						{
;;;394    							emergency = i;
;;;395    						}
;;;396    					}
;;;397    					if(15 == emergency)
;;;398    					{
;;;399    						sum = sum/cnt;
;;;400    		
;;;401    						if(sum>0)
;;;402    						{
;;;403    							Urstick = sum - 90;
;;;404    						}
;;;405    						else
;;;406    						{
;;;407    							Urstick = 90 + sum;
;;;408    						}
;;;409    					}
;;;410    					else
;;;411    					{
;;;412    						if(emergency > 6)
;;;413    						{Urstick = -70;}
;;;414    						else if(emergency < 6)
;;;415    						{Urstick = 70;}
;;;416    						else
;;;417    						{Ufstick = -50;}
;;;418    					}	
;;;419    ***/					
;;;420    				}
000dce  bf00              NOP      
                  |L1.3536|
;;;421    			   	/***********
;;;422    				i=0;
;;;423    				do											//搜索就近可行驶方向
;;;424    				{
;;;425    					if((udir+i+1)<13)							//搜索左方
;;;426    					{
;;;427    						if(0 == Lfound)
;;;428    						{
;;;429    							if(s[udir+i].dis>danger && s[udir+i+1].dis>danger)
;;;430    							{
;;;431    								Ln = udir+i+1;					//如果连续两个探头方向安全
;;;432    								Lfound = 1;						//取第二个探头方向为行驶方向
;;;433    							}	
;;;434    						}
;;;435    					}
;;;436    					else
;;;437    					{
;;;438    						Ln = 13;							//如果左方没有可行方向，停止搜索
;;;439    						Lfound = 1;							//通告左方搜索完毕
;;;440    					}
;;;441    					if((udir-i)>0)							//搜索右方
;;;442    					{
;;;443    						if(0 == Rfound)
;;;444    						{
;;;445    							if(s[udir-i].dis>danger && s[udir-i-1].dis>danger)
;;;446    							{
;;;447    								Rn = udir-i-1;					//如果连续两个探头方向安全
;;;448    								Rfound = 1;						//取第二个探头方向为行驶方向
;;;449    							}
;;;450    						}
;;;451    					}
;;;452    					else
;;;453    					{
;;;454    						Rn = 13;							//如果右方没有可行方向，停止搜索
;;;455    						Rfound = 1;							//通告右方搜索完毕
;;;456    					}
;;;457    					i++;	
;;;458    				}
;;;459    				while(Lfound==0 || Rfound ==0);				//如果没有搜索完成，继续搜索
;;;460    	
;;;461    				if(13 == Ln && 13 == Rn)					//如果左右都没有可行方向，停车
;;;462    				{
;;;463    					Urstick = 0;
;;;464    					Ufstick = 0;
;;;465    				}
;;;466    	
;;;467    				else if(13 != Ln && 13 == Rn)				//如果左方是就近行驶方向
;;;468    				{
;;;469    					Urstick = Ln*15 - 90;					//行驶方向转换为手柄数据
;;;470    				}
;;;471    				else if(13 == Ln && 13 != Rn)
;;;472    				{											//如果右侧是就近行驶方向
;;;473    					Urstick = Rn*15 - 90;					//行驶方向转换为手柄数据
;;;474    				}
;;;475    				else
;;;476    				{
;;;477    					if((udir-Rn)>(Ln-udir))
;;;478    					{
;;;479    						Urstick = Ln*15 - 90;
;;;480    					}
;;;481    					else
;;;482    					{
;;;483    						Urstick = Rn*15 - 90;
;;;484    					}
;;;485    				}
;;;486    				**************/
;;;487    				
;;;488    				Rstick = Urstick;
000dd0  48d4              LDR      r0,|L1.4388|
000dd2  f9b00000          LDRSH    r0,[r0,#0]  ; Urstick
000dd6  49d4              LDR      r1,|L1.4392|
000dd8  8008              STRH     r0,[r1,#0]
;;;489    				Fstick = Ufstick;
000dda  48ce              LDR      r0,|L1.4372|
000ddc  f9b00000          LDRSH    r0,[r0,#0]  ; Ufstick
000de0  49d2              LDR      r1,|L1.4396|
000de2  8008              STRH     r0,[r1,#0]
000de4  e004              B        |L1.3568|
                  |L1.3558|
;;;490    			}	
;;;491    		}												    //指令计算结束
;;;492    //		Fstick = 40;
;;;493    		else												//如果没有收到运动指令，速度清零
;;;494    		{
;;;495    			Rstick = 0;
000de6  2000              MOVS     r0,#0
000de8  49cf              LDR      r1,|L1.4392|
000dea  8008              STRH     r0,[r1,#0]
;;;496    			Fstick = 0;	
000dec  49cf              LDR      r1,|L1.4396|
000dee  8008              STRH     r0,[r1,#0]
                  |L1.3568|
;;;497    		}
;;;498    
;;;499    		SendCommand(Rstick,Fstick);              			//发送运动指令
000df0  48ce              LDR      r0,|L1.4396|
000df2  f9b01000          LDRSH    r1,[r0,#0]  ; Fstick
000df6  48cc              LDR      r0,|L1.4392|
000df8  f9b00000          LDRSH    r0,[r0,#0]  ; Rstick
000dfc  f7fffffe          BL       SendCommand
                  |L1.3584|
;;;500    
;;;501    
;;;502    //		 for(i=0;i<13;i++)								//时间量转换为距离量，进而转换为密度矢量
;;;503    //		 {
;;;504    //		 	s[i].dis = 0.17 * s[i].ctime;
;;;505    //			if(s[i].dis < warn)
;;;506    //			{
;;;507    //				s[i].vec = (warn - s[i].dis) / avoidis;
;;;508    //			}
;;;509    //			else
;;;510    //			{
;;;511    //				s[i].vec = 0;
;;;512    //			}
;;;513    //		 }
;;;514    		
;;;515    
;;;516    
;;;517    
;;;518    					
;;;519    //			sendtosharectl();
;;;520    		
;;;521    /****	
;;;522    			for(i=0;i<16;i++)						  //时间量转换为距离量，测试数据
;;;523    			{
;;;524    				s[i].dis = s[i].ctime * 17 / 100;
;;;525    			}
;;;526    			sprintf(buff,"%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\n",s[0].dis,\
;;;527    			s[1].dis,s[2].dis,s[3].dis,s[4].dis,s[5].dis,s[6].dis,s[7].dis,s[8].dis,\
;;;528    			s[9].dis,s[10].dis,s[11].dis,s[12].dis,s[13].dis,s[14].dis,s[15].dis);
;;;529    			senddata(buff,sizeof(buff));
;;;530    *****/	 
;;;531    		}
;;;532    
;;;533    		sequence++;									//指向下一个序列   
000e00  48cb              LDR      r0,|L1.4400|
000e02  8800              LDRH     r0,[r0,#0]  ; sequence
000e04  1c40              ADDS     r0,r0,#1
000e06  49ca              LDR      r1,|L1.4400|
000e08  8008              STRH     r0,[r1,#0]
                  |L1.3594|
000e0a  f7ffba6b          B        |L1.740|
;;;534           
;;;535    
;;;536    
;;;537    //       Rstick = vff(s,&RxCtl);                   //计算合成角速度
;;;538    
;;;539    //	   if(abs(Fstick)<20)						   //人造死区，速度过低时，停车
;;;540    //	   {Fstick = 0;}
;;;541    //	   if(abs(Rstick)<20)
;;;542    //	   {Rstick = 0;}
;;;543    //	   if(abs(Fstick)>70)
;;;544    //	   {Fstick = 70;}
;;;545    //	   if(abs(Rstick)>70)
;;;546    //	   {Rstick = 70;}
;;;547    //	   Rstick = RxCtl.buffer[11];
;;;548    //	   Rstick =atan2(1,1)/pi*180.0;
;;;549    //	   test();
;;;550    //       SendCommand(5*Rstick,5*Fstick);              //发送新的运动指令
;;;551           
;;;552    
;;;553    //		if(buff[i] != '\0')
;;;554    //		{
;;;555    //			for(i=0;i<100;i++)
;;;556    //			{
;;;557    //				buff[i] = '\0';
;;;558    //			}
;;;559    //		}										//清空缓冲区
;;;560    	}
;;;561    
;;;562       
;;;563    
;;;564    }
;;;565    
                          ENDP

                  userdir PROC
;;;566    uint8_t userdir(int Ufstick,int Urstick)
000e0e  e92d47f0          PUSH     {r4-r10,lr}
;;;567    {
000e12  4682              MOV      r10,r0
000e14  4688              MOV      r8,r1
;;;568    	uint8_t dir;
;;;569    	dir = (Urstick+70)/(140.0/12);
000e16  f1080046          ADD      r0,r8,#0x46
000e1a  f7fffffe          BL       __aeabi_i2d
000e1e  4606              MOV      r6,r0
000e20  f04f3255          MOV      r2,#0x55555555
000e24  4bc3              LDR      r3,|L1.4404|
000e26  f7fffffe          BL       __aeabi_ddiv
000e2a  4604              MOV      r4,r0
000e2c  f7fffffe          BL       __aeabi_d2uiz
000e30  f00009ff          AND      r9,r0,#0xff
;;;570    	return (13-dir);
000e34  f1c9000d          RSB      r0,r9,#0xd
000e38  b2c0              UXTB     r0,r0
;;;571    }
000e3a  e8bd87f0          POP      {r4-r10,pc}
;;;572    
                          ENDP

                  vff PROC
;;;602    
;;;603    int16_t vff(sonar *s,control *RxCtl)
000e3e  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;604    {
000e42  b09d              SUB      sp,sp,#0x74
000e44  468b              MOV      r11,r1
;;;605    	int16_t n,theta;
;;;606    	float amp,ang;
;;;607    	float rx,ry,r;							    //定义分解后的水平和垂直分量
;;;608    	float repulse[13];						    //定义13个斥力
;;;609    	int8_t resultant,rspeed;				    //合力
;;;610    	rx = 0;
000e46  2000              MOVS     r0,#0
000e48  901a              STR      r0,[sp,#0x68]
;;;611    	ry = 0;
000e4a  9019              STR      r0,[sp,#0x64]
;;;612    
;;;613    	if(RxCtl->buffer[10]<0)						//如果倒车，直接返回控制角度，不作处理
000e4c  f99b000a          LDRSB    r0,[r11,#0xa]
000e50  2800              CMP      r0,#0
000e52  da04              BGE      |L1.3678|
;;;614    	{return RxCtl->buffer[11];}
000e54  f99b000b          LDRSB    r0,[r11,#0xb]
                  |L1.3672|
;;;615    
;;;616    //	for(n=0;n<13;n++)
;;;617    //	{
;;;618    //		if(((s+n)->dis) < 400)
;;;619    //		{Fstick = 0;Rstick = 0;return 0;}		//如果发现有距离小于400，测试停车
;;;620    //	}
;;;621    
;;;622    	for(n=0;n<13;n++)
;;;623    	{	
;;;624    		if( ((s+n)->dis) > warn )				//距离大于避障距离，斥力为0
;;;625    		{
;;;626    			repulse[n] = 0;
;;;627    		}
;;;628    //		else if( ((s+n)->dis) < 400 )
;;;629    //		{
;;;630    //			repulse[n] = (1000 - (s+n)->dis)/600.0 ; 
;;;631    //		}
;;;632    		else
;;;633    		{
;;;634    			repulse[n] = (warn - (s+n)->dis)/(warn - danger) ;
;;;635    		}										 //距离小于warn，计算斥力产生的角速度
;;;636    		rx += repulse[n] * cos((-15*n)/180.0*PI);//将斥力叠加
;;;637    		ry += repulse[n] * sin((-15*n)/180.0*PI);//相反方向产生一个斥力
;;;638    	}	
;;;639    	
;;;640    	ang = (RxCtl->buffer[11] + 70)/(AD*2)*PI;	//手柄输入，弧度
;;;641    
;;;642    //	if((RxCtl->buffer[11]) > 0)					//幅值为采样绝对值除以量程
;;;643    //	{											//角度为幅值乘以方向
;;;644    //		amp = (RxCtl->buffer[11])/AD;
;;;645    //		ang = 90 * RxCtl->buffer[11] / AD;
;;;646    //	}
;;;647    //	else
;;;648    //	{
;;;649    //		amp = -(RxCtl->buffer[11])/AD;
;;;650    //		ang = 90 * RxCtl->buffer[11]/ AD;
;;;651    //	}
;;;652    //	rx =rx * (1-weights) + amp * cos((90 + ang)/180.0*pi)*weights;
;;;653    //	ry =ry * (1-weights) + amp * sin((90 + ang)/180.0*pi)*weights;
;;;654    
;;;655    //	rx =rx  + 1 * cos(ang);
;;;656    //	ry =ry  + 1 * sin(ang);
;;;657    
;;;658    //	r = sqrt(rx*rx + ry*ry);					//笛卡尔坐标系角度x，轮椅坐标系角度y
;;;659                                                    //y = 90 - x; x = 90 - y
;;;660    	theta = atan2(ry,rx)/PI*180.0;              //合力方向,笛卡尔坐标系			
;;;661    //	theta = theta-90;                           //返回轮椅坐标系方向
;;;662    //	resultant = abs(theta)/90.0*AD;
;;;663    	if(theta>-90)
;;;664    	{
;;;665    		resultant = -abs(theta)/90.0*AD; 
;;;666    		return (resultant*weights);
;;;667    	}
;;;668    	else
;;;669    	{
;;;670    		resultant = (180.0+theta)/90.0*AD;
;;;671    		return (resultant*weights);
;;;672    	}
;;;673    
;;;674    }
000e58  b01f              ADD      sp,sp,#0x7c
000e5a  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.3678|
000e5e  f04f0800          MOV      r8,#0                 ;622
000e62  e081              B        |L1.3944|
                  |L1.3684|
000e64  eb080148          ADD      r1,r8,r8,LSL #1       ;624
000e68  981d              LDR      r0,[sp,#0x74]         ;624
000e6a  eb0000c1          ADD      r0,r0,r1,LSL #3       ;624
000e6e  8900              LDRH     r0,[r0,#8]            ;624
000e70  f5b07ffa          CMP      r0,#0x1f4             ;624
000e74  dd04              BLE      |L1.3712|
000e76  2000              MOVS     r0,#0                 ;626
000e78  a90c              ADD      r1,sp,#0x30           ;626
000e7a  f8410028          STR      r0,[r1,r8,LSL #2]     ;626
000e7e  e010              B        |L1.3746|
                  |L1.3712|
000e80  eb080148          ADD      r1,r8,r8,LSL #1       ;634
000e84  981d              LDR      r0,[sp,#0x74]         ;634
000e86  eb0000c1          ADD      r0,r0,r1,LSL #3       ;634
000e8a  8900              LDRH     r0,[r0,#8]            ;634
000e8c  f5c070fa          RSB      r0,r0,#0x1f4          ;634
000e90  21c8              MOVS     r1,#0xc8              ;634
000e92  fb90f4f1          SDIV     r4,r0,r1              ;634
000e96  4620              MOV      r0,r4                 ;634
000e98  f7fffffe          BL       __aeabi_i2f
000e9c  a90c              ADD      r1,sp,#0x30           ;634
000e9e  f8410028          STR      r0,[r1,r8,LSL #2]     ;634
                  |L1.3746|
000ea2  eba81008          SUB      r0,r8,r8,LSL #4       ;636
000ea6  f7fffffe          BL       __aeabi_i2d
000eaa  4606              MOV      r6,r0                 ;636
000eac  2200              MOVS     r2,#0                 ;636
000eae  4b9c              LDR      r3,|L1.4384|
000eb0  f7fffffe          BL       __aeabi_ddiv
000eb4  4604              MOV      r4,r0                 ;636
000eb6  4a98              LDR      r2,|L1.4376|
000eb8  4b98              LDR      r3,|L1.4380|
000eba  f7fffffe          BL       __aeabi_dmul
000ebe  e9cd0100          STRD     r0,r1,[sp,#0]         ;636
000ec2  f7fffffe          BL       ||cos||
000ec6  e9cd0104          STRD     r0,r1,[sp,#0x10]      ;636
000eca  a90c              ADD      r1,sp,#0x30           ;636
000ecc  f8510028          LDR      r0,[r1,r8,LSL #2]     ;636
000ed0  f7fffffe          BL       __aeabi_f2d
000ed4  e9cd0102          STRD     r0,r1,[sp,#8]         ;636
000ed8  e9dd2304          LDRD     r2,r3,[sp,#0x10]      ;636
000edc  f7fffffe          BL       __aeabi_dmul
000ee0  e9cd0108          STRD     r0,r1,[sp,#0x20]      ;636
000ee4  981a              LDR      r0,[sp,#0x68]         ;636
000ee6  f7fffffe          BL       __aeabi_f2d
000eea  e9cd0106          STRD     r0,r1,[sp,#0x18]      ;636
000eee  e9dd2308          LDRD     r2,r3,[sp,#0x20]      ;636
000ef2  f7fffffe          BL       __aeabi_dadd
000ef6  e9cd010a          STRD     r0,r1,[sp,#0x28]      ;636
000efa  f7fffffe          BL       __aeabi_d2f
000efe  901a              STR      r0,[sp,#0x68]         ;636
000f00  eba81008          SUB      r0,r8,r8,LSL #4       ;637
000f04  f7fffffe          BL       __aeabi_i2d
000f08  2200              MOVS     r2,#0                 ;637
000f0a  4b85              LDR      r3,|L1.4384|
000f0c  e9cd0100          STRD     r0,r1,[sp,#0]         ;637
000f10  f7fffffe          BL       __aeabi_ddiv
000f14  4a80              LDR      r2,|L1.4376|
000f16  4b81              LDR      r3,|L1.4380|
000f18  e9cd0102          STRD     r0,r1,[sp,#8]         ;637
000f1c  f7fffffe          BL       __aeabi_dmul
000f20  e9cd0104          STRD     r0,r1,[sp,#0x10]      ;637
000f24  f7fffffe          BL       ||sin||
000f28  4604              MOV      r4,r0                 ;637
000f2a  460d              MOV      r5,r1                 ;637
000f2c  a90c              ADD      r1,sp,#0x30           ;637
000f2e  f8510028          LDR      r0,[r1,r8,LSL #2]     ;637
000f32  f7fffffe          BL       __aeabi_f2d
000f36  4622              MOV      r2,r4                 ;637
000f38  462b              MOV      r3,r5                 ;637
000f3a  e9cd0106          STRD     r0,r1,[sp,#0x18]      ;637
000f3e  f7fffffe          BL       __aeabi_dmul
000f42  e9cd0108          STRD     r0,r1,[sp,#0x20]      ;637
000f46  9819              LDR      r0,[sp,#0x64]         ;637
000f48  f7fffffe          BL       __aeabi_f2d
000f4c  4606              MOV      r6,r0                 ;637
000f4e  e9dd2308          LDRD     r2,r3,[sp,#0x20]      ;637
000f52  f7fffffe          BL       __aeabi_dadd
000f56  e9cd010a          STRD     r0,r1,[sp,#0x28]      ;637
000f5a  f7fffffe          BL       __aeabi_d2f
000f5e  9019              STR      r0,[sp,#0x64]         ;637
000f60  f1080001          ADD      r0,r8,#1              ;622
000f64  fa0ff880          SXTH     r8,r0                 ;622
                  |L1.3944|
000f68  f1b80f0d          CMP      r8,#0xd               ;622
000f6c  f6ffaf7a          BLT      |L1.3684|
000f70  f99b100b          LDRSB    r1,[r11,#0xb]         ;640
000f74  f1010046          ADD      r0,r1,#0x46           ;640
000f78  f7fffffe          BL       __aeabi_i2d
000f7c  2200              MOVS     r2,#0                 ;640
000f7e  4b6e              LDR      r3,|L1.4408|
000f80  e9cd010a          STRD     r0,r1,[sp,#0x28]      ;640
000f84  f7fffffe          BL       __aeabi_ddiv
000f88  4604              MOV      r4,r0                 ;640
000f8a  4a63              LDR      r2,|L1.4376|
000f8c  4b63              LDR      r3,|L1.4380|
000f8e  f7fffffe          BL       __aeabi_dmul
000f92  4606              MOV      r6,r0                 ;640
000f94  f7fffffe          BL       __aeabi_d2f
000f98  901b              STR      r0,[sp,#0x6c]         ;640
000f9a  981a              LDR      r0,[sp,#0x68]         ;660
000f9c  f7fffffe          BL       __aeabi_f2d
000fa0  4606              MOV      r6,r0                 ;660
000fa2  460f              MOV      r7,r1                 ;660
000fa4  9819              LDR      r0,[sp,#0x64]         ;660
000fa6  f7fffffe          BL       __aeabi_f2d
000faa  4632              MOV      r2,r6                 ;660
000fac  463b              MOV      r3,r7                 ;660
000fae  e9cd0106          STRD     r0,r1,[sp,#0x18]      ;660
000fb2  f7fffffe          BL       atan2
000fb6  4a58              LDR      r2,|L1.4376|
000fb8  4b58              LDR      r3,|L1.4380|
000fba  e9cd0108          STRD     r0,r1,[sp,#0x20]      ;660
000fbe  f7fffffe          BL       __aeabi_ddiv
000fc2  4604              MOV      r4,r0                 ;660
000fc4  2200              MOVS     r2,#0                 ;660
000fc6  4b56              LDR      r3,|L1.4384|
000fc8  f7fffffe          BL       __aeabi_dmul
000fcc  e9cd010a          STRD     r0,r1,[sp,#0x28]      ;660
000fd0  f7fffffe          BL       __aeabi_d2iz
000fd4  fa0ffa80          SXTH     r10,r0                ;660
000fd8  f11a0f5a          CMN      r10,#0x5a             ;663
000fdc  dd1d              BLE      |L1.4122|
000fde  f8cda02c          STR      r10,[sp,#0x2c]        ;665
000fe2  f1ba0f00          CMP      r10,#0                ;665
000fe6  db01              BLT      |L1.4076|
000fe8  990b              LDR      r1,[sp,#0x2c]         ;665
000fea  e001              B        |L1.4080|
                  |L1.4076|
000fec  990b              LDR      r1,[sp,#0x2c]         ;665
000fee  4249              RSBS     r1,r1,#0              ;665
                  |L1.4080|
000ff0  4248              RSBS     r0,r1,#0              ;665
000ff2  f7fffffe          BL       __aeabi_i2d
000ff6  2200              MOVS     r2,#0                 ;665
000ff8  4b50              LDR      r3,|L1.4412|
000ffa  e9cd0108          STRD     r0,r1,[sp,#0x20]      ;665
000ffe  f7fffffe          BL       __aeabi_ddiv
001002  4606              MOV      r6,r0                 ;665
001004  2200              MOVS     r2,#0                 ;665
001006  4b4e              LDR      r3,|L1.4416|
001008  f7fffffe          BL       __aeabi_dmul
00100c  4604              MOV      r4,r0                 ;665
00100e  f7fffffe          BL       __aeabi_d2iz
001012  fa4ff980          SXTB     r9,r0                 ;665
001016  4648              MOV      r0,r9                 ;666
001018  e71e              B        |L1.3672|
                  |L1.4122|
00101a  4650              MOV      r0,r10                ;670
00101c  f7fffffe          BL       __aeabi_i2d
001020  2200              MOVS     r2,#0                 ;670
001022  4b3f              LDR      r3,|L1.4384|
001024  e9cd0108          STRD     r0,r1,[sp,#0x20]      ;670
001028  f7fffffe          BL       __aeabi_dadd
00102c  4606              MOV      r6,r0                 ;670
00102e  2200              MOVS     r2,#0                 ;670
001030  4b42              LDR      r3,|L1.4412|
001032  f7fffffe          BL       __aeabi_ddiv
001036  2200              MOVS     r2,#0                 ;670
001038  4b41              LDR      r3,|L1.4416|
00103a  e9cd010a          STRD     r0,r1,[sp,#0x28]      ;670
00103e  f7fffffe          BL       __aeabi_dmul
001042  4604              MOV      r4,r0                 ;670
001044  f7fffffe          BL       __aeabi_d2iz
001048  fa4ff980          SXTB     r9,r0                 ;670
00104c  4648              MOV      r0,r9                 ;671
00104e  e703              B        |L1.3672|
;;;675    
                          ENDP

                  sendtosharectl PROC
;;;676    void sendtosharectl(void)
001050  b5fe              PUSH     {r1-r7,lr}
;;;677    {
;;;678    	 uint8_t string[10];
;;;679    	 uint8_t cnt = 0;
001052  2500              MOVS     r5,#0
;;;680    	 uint8_t n = 0;
001054  2400              MOVS     r4,#0
;;;681    	 uint8_t sdata;
;;;682    	 
;;;683    	 sprintf(string, "sonar");			  		//定义数据头
001056  a13b              ADR      r1,|L1.4420|
001058  4668              MOV      r0,sp
00105a  f7fffffe          BL       __2sprintf
;;;684    	 
;;;685    	 while(cnt <sizeof(string))     		    //发送数据头
00105e  e012              B        |L1.4230|
                  |L1.4192|
;;;686    	 {
;;;687    		  if(string[cnt] == '\0')break;
001060  f81d0005          LDRB     r0,[sp,r5]
001064  b900              CBNZ     r0,|L1.4200|
001066  e010              B        |L1.4234|
                  |L1.4200|
;;;688    		  USART_SendData(USART1,string[cnt++]);
001068  4628              MOV      r0,r5
00106a  1c6a              ADDS     r2,r5,#1
00106c  b2d5              UXTB     r5,r2
00106e  f81d1000          LDRB     r1,[sp,r0]
001072  4836              LDR      r0,|L1.4428|
001074  f7fffffe          BL       USART_SendData
;;;689    		  while(USART_GetFlagStatus(USART1,USART_FLAG_TC) == RESET);
001078  bf00              NOP      
                  |L1.4218|
00107a  2140              MOVS     r1,#0x40
00107c  4833              LDR      r0,|L1.4428|
00107e  f7fffffe          BL       USART_GetFlagStatus
001082  2800              CMP      r0,#0
001084  d0f9              BEQ      |L1.4218|
                  |L1.4230|
001086  2d0a              CMP      r5,#0xa               ;685
001088  d3ea              BCC      |L1.4192|
                  |L1.4234|
00108a  bf00              NOP                            ;687
;;;690    	 }     
;;;691    	 
;;;692    	 for(n=0;n<13;n++)  
00108c  2400              MOVS     r4,#0
00108e  e025              B        |L1.4316|
                  |L1.4240|
;;;693    	 {							 		
;;;694    		  sdata = s[n].dis;      				//发送低位
001090  eb040044          ADD      r0,r4,r4,LSL #1
001094  492e              LDR      r1,|L1.4432|
001096  eb0100c0          ADD      r0,r1,r0,LSL #3
00109a  8900              LDRH     r0,[r0,#8]
00109c  b2c6              UXTB     r6,r0
;;;695    		  USART_SendData(USART1,sdata);
00109e  4631              MOV      r1,r6
0010a0  482a              LDR      r0,|L1.4428|
0010a2  f7fffffe          BL       USART_SendData
;;;696    		  while(USART_GetFlagStatus(USART1,USART_FLAG_TC) == RESET);
0010a6  bf00              NOP      
                  |L1.4264|
0010a8  2140              MOVS     r1,#0x40
0010aa  4828              LDR      r0,|L1.4428|
0010ac  f7fffffe          BL       USART_GetFlagStatus
0010b0  2800              CMP      r0,#0
0010b2  d0f9              BEQ      |L1.4264|
;;;697    	  
;;;698    		
;;;699    		  sdata = s[n].dis>>8;    				//发送高位
0010b4  eb040044          ADD      r0,r4,r4,LSL #1
0010b8  4925              LDR      r1,|L1.4432|
0010ba  eb0100c0          ADD      r0,r1,r0,LSL #3
0010be  8900              LDRH     r0,[r0,#8]
0010c0  1206              ASRS     r6,r0,#8
;;;700    		  USART_SendData(USART1,sdata);
0010c2  4631              MOV      r1,r6
0010c4  4821              LDR      r0,|L1.4428|
0010c6  f7fffffe          BL       USART_SendData
;;;701    		  while(USART_GetFlagStatus(USART1,USART_FLAG_TC) == RESET);
0010ca  bf00              NOP      
                  |L1.4300|
0010cc  2140              MOVS     r1,#0x40
0010ce  481f              LDR      r0,|L1.4428|
0010d0  f7fffffe          BL       USART_GetFlagStatus
0010d4  2800              CMP      r0,#0
0010d6  d0f9              BEQ      |L1.4300|
0010d8  1c60              ADDS     r0,r4,#1              ;692
0010da  b2c4              UXTB     r4,r0                 ;692
                  |L1.4316|
0010dc  2c0d              CMP      r4,#0xd               ;692
0010de  dbd7              BLT      |L1.4240|
;;;702    	 } 
;;;703    
;;;704    }
0010e0  bdfe              POP      {r1-r7,pc}
;;;705    
                          ENDP

                  TIM1_Configuration PROC
;;;794    
;;;795    void TIM1_Configuration(void)
0010e2  b500              PUSH     {lr}
;;;796    {
0010e4  b087              SUB      sp,sp,#0x1c
;;;797    	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;					//定时器初始化结构
;;;798        TIM_ICInitTypeDef TIM_ICInitStructure;        					//通道输入初始化结构
;;;799    
;;;800        //TIM1输出初始化
;;;801        TIM_TimeBaseStructure.TIM_Period = 0xFFFF;     					//周期0～FFFF
0010e6  f64f70ff          MOV      r0,#0xffff
0010ea  f8ad0014          STRH     r0,[sp,#0x14]
;;;802        TIM_TimeBaseStructure.TIM_Prescaler = 71;       				//时钟分频
0010ee  2047              MOVS     r0,#0x47
0010f0  f8ad0010          STRH     r0,[sp,#0x10]
;;;803        TIM_TimeBaseStructure.TIM_ClockDivision = 0;   					//时钟分割
0010f4  2000              MOVS     r0,#0
0010f6  f8ad0016          STRH     r0,[sp,#0x16]
;;;804        TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;		//模式
0010fa  f8ad0012          STRH     r0,[sp,#0x12]
;;;805        TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);					//基本初始化
0010fe  a904              ADD      r1,sp,#0x10
001100  4814              LDR      r0,|L1.4436|
001102  f7fffffe          BL       TIM_TimeBaseInit
;;;806    
;;;807    	//TIM1通道的捕捉初始化  
;;;808        TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;				//通道选择
001106  2000              MOVS     r0,#0
001108  f8ad0004          STRH     r0,[sp,#4]
;;;809        TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;		//边沿触发
00110c  f8ad0006          STRH     r0,[sp,#6]
;;;810        TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; //管脚与寄存器对应关系
001110  2001              MOVS     r0,#1
001112  e021              B        |L1.4440|
                  |L1.4372|
                          DCD      Ufstick
                  |L1.4376|
                          DCD      0x5a7ed197
                  |L1.4380|
                          DCD      0x400921fb
                  |L1.4384|
                          DCD      0x40668000
                  |L1.4388|
                          DCD      Urstick
                  |L1.4392|
                          DCD      Rstick
                  |L1.4396|
                          DCD      Fstick
                  |L1.4400|
                          DCD      sequence
                  |L1.4404|
                          DCD      0x40275555
                  |L1.4408|
                          DCD      0x40640000
                  |L1.4412|
                          DCD      0x40568000
                  |L1.4416|
                          DCD      0x40540000
                  |L1.4420|
001144  736f6e61          DCB      "sonar",0
001148  7200    
00114a  00                DCB      0
00114b  00                DCB      0
                  |L1.4428|
                          DCD      0x40013800
                  |L1.4432|
                          DCD      s
                  |L1.4436|
                          DCD      0x40012c00
                  |L1.4440|
001158  f8ad0008          STRH     r0,[sp,#8]
;;;811        TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			//分频器
00115c  2000              MOVS     r0,#0
00115e  f8ad000a          STRH     r0,[sp,#0xa]
;;;812        TIM_ICInitStructure.TIM_ICFilter = 0x0;        					//滤波设置，经历几个周期跳变认定波形稳定0x0～0xF
001162  f8ad000c          STRH     r0,[sp,#0xc]
;;;813        TIM_ICInit(TIM1, &TIM_ICInitStructure);        					//初始化
001166  a901              ADD      r1,sp,#4
001168  48be              LDR      r0,|L1.5220|
00116a  f7fffffe          BL       TIM_ICInit
;;;814    
;;;815    	TIM_ICInitStructure.TIM_Channel = TIM_Channel_4;				//通道选择
00116e  200c              MOVS     r0,#0xc
001170  f8ad0004          STRH     r0,[sp,#4]
;;;816        TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Falling;	//边沿触发
001174  2002              MOVS     r0,#2
001176  f8ad0006          STRH     r0,[sp,#6]
;;;817        TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; //管脚与寄存器对应关系
00117a  2001              MOVS     r0,#1
00117c  f8ad0008          STRH     r0,[sp,#8]
;;;818        TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			//分频器
001180  2000              MOVS     r0,#0
001182  f8ad000a          STRH     r0,[sp,#0xa]
;;;819        TIM_ICInitStructure.TIM_ICFilter = 0x0;        					//滤波设置，经历几个周期跳变认定波形稳定0x0～0xF
001186  f8ad000c          STRH     r0,[sp,#0xc]
;;;820        TIM_ICInit(TIM1, &TIM_ICInitStructure);        					//初始化
00118a  a901              ADD      r1,sp,#4
00118c  48b5              LDR      r0,|L1.5220|
00118e  f7fffffe          BL       TIM_ICInit
;;;821      
;;;822        TIM_ITConfig(TIM1, TIM_IT_CC1, ENABLE);        					//打开中断
001192  2201              MOVS     r2,#1
001194  2102              MOVS     r1,#2
001196  48b3              LDR      r0,|L1.5220|
001198  f7fffffe          BL       TIM_ITConfig
;;;823    	TIM_ITConfig(TIM1, TIM_IT_CC2, ENABLE);        					//打开中断
00119c  2201              MOVS     r2,#1
00119e  2104              MOVS     r1,#4
0011a0  48b0              LDR      r0,|L1.5220|
0011a2  f7fffffe          BL       TIM_ITConfig
;;;824      
;;;825        TIM_Cmd(TIM1, ENABLE);                         					//启动TIM1	
0011a6  2101              MOVS     r1,#1
0011a8  48ae              LDR      r0,|L1.5220|
0011aa  f7fffffe          BL       TIM_Cmd
;;;826    }
0011ae  b007              ADD      sp,sp,#0x1c
0011b0  bd00              POP      {pc}
;;;827    
                          ENDP

                  TIM3_Configuration PROC
;;;828    void TIM3_Configuration(void)
0011b2  b500              PUSH     {lr}
;;;829    {
0011b4  b087              SUB      sp,sp,#0x1c
;;;830    	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;					//定时器初始化结构
;;;831        TIM_ICInitTypeDef TIM_ICInitStructure;        					//通道输入初始化结构
;;;832    
;;;833        //TIM3输出初始化
;;;834        TIM_TimeBaseStructure.TIM_Period = 0xFFFF;     					//周期0～FFFF
0011b6  f64f70ff          MOV      r0,#0xffff
0011ba  f8ad0014          STRH     r0,[sp,#0x14]
;;;835        TIM_TimeBaseStructure.TIM_Prescaler = 71;       				//时钟分频
0011be  2047              MOVS     r0,#0x47
0011c0  f8ad0010          STRH     r0,[sp,#0x10]
;;;836        TIM_TimeBaseStructure.TIM_ClockDivision = 0;   					//时钟分割
0011c4  2000              MOVS     r0,#0
0011c6  f8ad0016          STRH     r0,[sp,#0x16]
;;;837        TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;		//模式
0011ca  f8ad0012          STRH     r0,[sp,#0x12]
;;;838        TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);					//基本初始化
0011ce  a904              ADD      r1,sp,#0x10
0011d0  48a5              LDR      r0,|L1.5224|
0011d2  f7fffffe          BL       TIM_TimeBaseInit
;;;839    
;;;840    	//TIM4通道的捕捉初始化  
;;;841        TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;				//通道选择
0011d6  2000              MOVS     r0,#0
0011d8  f8ad0004          STRH     r0,[sp,#4]
;;;842        TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;		//边沿触发
0011dc  f8ad0006          STRH     r0,[sp,#6]
;;;843        TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; //管脚与寄存器对应关系
0011e0  2001              MOVS     r0,#1
0011e2  f8ad0008          STRH     r0,[sp,#8]
;;;844        TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			//分频器
0011e6  2000              MOVS     r0,#0
0011e8  f8ad000a          STRH     r0,[sp,#0xa]
;;;845        TIM_ICInitStructure.TIM_ICFilter = 0x0;        					//滤波设置，经历几个周期跳变认定波形稳定0x0～0xF
0011ec  f8ad000c          STRH     r0,[sp,#0xc]
;;;846        TIM_ICInit(TIM3, &TIM_ICInitStructure);        					//初始化
0011f0  a901              ADD      r1,sp,#4
0011f2  489d              LDR      r0,|L1.5224|
0011f4  f7fffffe          BL       TIM_ICInit
;;;847    
;;;848    	TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;				//通道选择
0011f8  2004              MOVS     r0,#4
0011fa  f8ad0004          STRH     r0,[sp,#4]
;;;849        TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Falling;	//边沿触发
0011fe  2002              MOVS     r0,#2
001200  f8ad0006          STRH     r0,[sp,#6]
;;;850        TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; //管脚与寄存器对应关系
001204  2001              MOVS     r0,#1
001206  f8ad0008          STRH     r0,[sp,#8]
;;;851        TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			//分频器
00120a  2000              MOVS     r0,#0
00120c  f8ad000a          STRH     r0,[sp,#0xa]
;;;852        TIM_ICInitStructure.TIM_ICFilter = 0x0;        					//滤波设置，经历几个周期跳变认定波形稳定0x0～0xF
001210  f8ad000c          STRH     r0,[sp,#0xc]
;;;853        TIM_ICInit(TIM3, &TIM_ICInitStructure);        					//初始化
001214  a901              ADD      r1,sp,#4
001216  4894              LDR      r0,|L1.5224|
001218  f7fffffe          BL       TIM_ICInit
;;;854      
;;;855        TIM_ITConfig(TIM3, TIM_IT_CC1, ENABLE);        					//打开中断
00121c  2201              MOVS     r2,#1
00121e  2102              MOVS     r1,#2
001220  4891              LDR      r0,|L1.5224|
001222  f7fffffe          BL       TIM_ITConfig
;;;856    	TIM_ITConfig(TIM3, TIM_IT_CC2, ENABLE);        					//打开中断
001226  2201              MOVS     r2,#1
001228  2104              MOVS     r1,#4
00122a  488f              LDR      r0,|L1.5224|
00122c  f7fffffe          BL       TIM_ITConfig
;;;857      
;;;858        TIM_Cmd(TIM3, ENABLE);                         					//启动TIM3	
001230  2101              MOVS     r1,#1
001232  488d              LDR      r0,|L1.5224|
001234  f7fffffe          BL       TIM_Cmd
;;;859    }
001238  b007              ADD      sp,sp,#0x1c
00123a  bd00              POP      {pc}
;;;860    
                          ENDP

                  TIM4_Configuration PROC
;;;861    void TIM4_Configuration(void)
00123c  b500              PUSH     {lr}
;;;862    {
00123e  b087              SUB      sp,sp,#0x1c
;;;863    	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;					//定时器初始化结构
;;;864        TIM_ICInitTypeDef TIM_ICInitStructure;        					//通道输入初始化结构
;;;865    
;;;866        //TIM4输出初始化
;;;867        TIM_TimeBaseStructure.TIM_Period = 0xFFFF;     					//周期0～FFFF
001240  f64f70ff          MOV      r0,#0xffff
001244  f8ad0014          STRH     r0,[sp,#0x14]
;;;868        TIM_TimeBaseStructure.TIM_Prescaler = 71;       				//时钟分频
001248  2047              MOVS     r0,#0x47
00124a  f8ad0010          STRH     r0,[sp,#0x10]
;;;869        TIM_TimeBaseStructure.TIM_ClockDivision = 0;   					//时钟分割
00124e  2000              MOVS     r0,#0
001250  f8ad0016          STRH     r0,[sp,#0x16]
;;;870        TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;		//模式
001254  f8ad0012          STRH     r0,[sp,#0x12]
;;;871        TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);					//基本初始化
001258  a904              ADD      r1,sp,#0x10
00125a  4884              LDR      r0,|L1.5228|
00125c  f7fffffe          BL       TIM_TimeBaseInit
;;;872    
;;;873    	//TIM4通道的捕捉初始化  
;;;874        TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;				//通道选择
001260  2000              MOVS     r0,#0
001262  f8ad0004          STRH     r0,[sp,#4]
;;;875        TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;		//边沿触发
001266  f8ad0006          STRH     r0,[sp,#6]
;;;876        TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; //管脚与寄存器对应关系
00126a  2001              MOVS     r0,#1
00126c  f8ad0008          STRH     r0,[sp,#8]
;;;877        TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			//分频器
001270  2000              MOVS     r0,#0
001272  f8ad000a          STRH     r0,[sp,#0xa]
;;;878        TIM_ICInitStructure.TIM_ICFilter = 0x0;        					//滤波设置，经历几个周期跳变认定波形稳定0x0～0xF
001276  f8ad000c          STRH     r0,[sp,#0xc]
;;;879        TIM_ICInit(TIM4, &TIM_ICInitStructure);        					//初始化
00127a  a901              ADD      r1,sp,#4
00127c  487b              LDR      r0,|L1.5228|
00127e  f7fffffe          BL       TIM_ICInit
;;;880    
;;;881    	TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;				//通道选择
001282  2004              MOVS     r0,#4
001284  f8ad0004          STRH     r0,[sp,#4]
;;;882        TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Falling;	//边沿触发
001288  2002              MOVS     r0,#2
00128a  f8ad0006          STRH     r0,[sp,#6]
;;;883        TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI; //管脚与寄存器对应关系
00128e  2001              MOVS     r0,#1
001290  f8ad0008          STRH     r0,[sp,#8]
;;;884        TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			//分频器
001294  2000              MOVS     r0,#0
001296  f8ad000a          STRH     r0,[sp,#0xa]
;;;885        TIM_ICInitStructure.TIM_ICFilter = 0x0;        					//滤波设置，经历几个周期跳变认定波形稳定0x0～0xF
00129a  f8ad000c          STRH     r0,[sp,#0xc]
;;;886        TIM_ICInit(TIM4, &TIM_ICInitStructure);        					//初始化
00129e  a901              ADD      r1,sp,#4
0012a0  4872              LDR      r0,|L1.5228|
0012a2  f7fffffe          BL       TIM_ICInit
;;;887      
;;;888        TIM_ITConfig(TIM4, TIM_IT_CC1, ENABLE);        					//打开中断
0012a6  2201              MOVS     r2,#1
0012a8  2102              MOVS     r1,#2
0012aa  4870              LDR      r0,|L1.5228|
0012ac  f7fffffe          BL       TIM_ITConfig
;;;889    	TIM_ITConfig(TIM4, TIM_IT_CC2, ENABLE);        					//打开中断
0012b0  2201              MOVS     r2,#1
0012b2  2104              MOVS     r1,#4
0012b4  486d              LDR      r0,|L1.5228|
0012b6  f7fffffe          BL       TIM_ITConfig
;;;890      
;;;891        TIM_Cmd(TIM4, ENABLE);                         					//启动TIM4	
0012ba  2101              MOVS     r1,#1
0012bc  486b              LDR      r0,|L1.5228|
0012be  f7fffffe          BL       TIM_Cmd
;;;892    }
0012c2  b007              ADD      sp,sp,#0x1c
0012c4  bd00              POP      {pc}
;;;893    
                          ENDP

                  delay_ms PROC
;;;966    
;;;967    void delay_ms(uint16_t nms)
0012c6  f44f717a          MOV      r1,#0x3e8
;;;968    {
;;;969    	TimingDelay = nms * 1000;
0012ca  4341              MULS     r1,r0,r1
0012cc  4a68              LDR      r2,|L1.5232|
0012ce  6011              STR      r1,[r2,#0]  ; TimingDelay
;;;970    	SysTick->CTRL |= SysTick_CTRL_ENABLE_Msk;
0012d0  f04f21e0          MOV      r1,#0xe000e000
0012d4  6909              LDR      r1,[r1,#0x10]
0012d6  f0410101          ORR      r1,r1,#1
0012da  f04f22e0          MOV      r2,#0xe000e000
0012de  6111              STR      r1,[r2,#0x10]
;;;971    	while(TimingDelay != 0);
0012e0  bf00              NOP      
                  |L1.4834|
0012e2  4963              LDR      r1,|L1.5232|
0012e4  6809              LDR      r1,[r1,#0]  ; TimingDelay
0012e6  2900              CMP      r1,#0
0012e8  d1fb              BNE      |L1.4834|
;;;972    }
0012ea  4770              BX       lr
;;;973    
                          ENDP

                  senddata PROC
;;;980    
;;;981    void senddata(uint8_t *buf, uint16_t num)
0012ec  b570              PUSH     {r4-r6,lr}
;;;982    {
0012ee  4604              MOV      r4,r0
0012f0  460e              MOV      r6,r1
;;;983    	uint8_t TxCount = 0;
0012f2  2500              MOVS     r5,#0
;;;984    	while(TxCount < num)
0012f4  e010              B        |L1.4888|
                  |L1.4854|
;;;985    	{
;;;986    		if(buf[TxCount] == '\0')break;
0012f6  5d60              LDRB     r0,[r4,r5]
0012f8  b900              CBNZ     r0,|L1.4860|
0012fa  e00f              B        |L1.4892|
                  |L1.4860|
;;;987    		USART_SendData(USART1,buf[TxCount++]);
0012fc  4628              MOV      r0,r5
0012fe  1c6a              ADDS     r2,r5,#1
001300  b2d5              UXTB     r5,r2
001302  5c21              LDRB     r1,[r4,r0]
001304  485b              LDR      r0,|L1.5236|
001306  f7fffffe          BL       USART_SendData
;;;988    		while(USART_GetFlagStatus(USART1,USART_FLAG_TC) == RESET);
00130a  bf00              NOP      
                  |L1.4876|
00130c  2140              MOVS     r1,#0x40
00130e  4859              LDR      r0,|L1.5236|
001310  f7fffffe          BL       USART_GetFlagStatus
001314  2800              CMP      r0,#0
001316  d0f9              BEQ      |L1.4876|
                  |L1.4888|
001318  42b5              CMP      r5,r6                 ;984
00131a  dbec              BLT      |L1.4854|
                  |L1.4892|
00131c  bf00              NOP                            ;986
;;;989    	} 
;;;990    }
00131e  bd70              POP      {r4-r6,pc}
;;;991    
                          ENDP

                  filter PROC
;;;992    void filter(sonar *sf, int len, int thred, int N)
001320  b5f0              PUSH     {r4-r7,lr}
;;;993    {
001322  4604              MOV      r4,r0
;;;994    	uint8_t i;
;;;995    	for(i=0;i<len;i++)
001324  2000              MOVS     r0,#0
001326  e03c              B        |L1.5026|
                  |L1.4904|
;;;996    	{
;;;997    		if(abs((sf+i)->ltime - (sf+i)->ctime)<thred || (sf+i)->fcnt > N )		  //数据稳定，清空标志位，保存当前数据
001328  eb000640          ADD      r6,r0,r0,LSL #1
00132c  f8346036          LDRH     r6,[r4,r6,LSL #3]
001330  eb000740          ADD      r7,r0,r0,LSL #1
001334  eb0407c7          ADD      r7,r4,r7,LSL #3
001338  887f              LDRH     r7,[r7,#2]
00133a  1bf5              SUBS     r5,r6,r7
00133c  d401              BMI      |L1.4930|
00133e  462e              MOV      r6,r5
001340  e000              B        |L1.4932|
                  |L1.4930|
001342  426e              RSBS     r6,r5,#0
                  |L1.4932|
001344  4296              CMP      r6,r2
001346  db06              BLT      |L1.4950|
001348  eb000640          ADD      r6,r0,r0,LSL #1
00134c  eb0406c6          ADD      r6,r4,r6,LSL #3
001350  7d36              LDRB     r6,[r6,#0x14]
001352  429e              CMP      r6,r3
001354  dd0f              BLE      |L1.4982|
                  |L1.4950|
;;;998    		{
;;;999    			(sf+i)->ltime = (sf+i)->ctime;
001356  eb000540          ADD      r5,r0,r0,LSL #1
00135a  eb0405c5          ADD      r5,r4,r5,LSL #3
00135e  886d              LDRH     r5,[r5,#2]
001360  eb000640          ADD      r6,r0,r0,LSL #1
001364  f8245036          STRH     r5,[r4,r6,LSL #3]
;;;1000   			(sf+i)->fcnt = 0;
001368  2500              MOVS     r5,#0
00136a  eb000640          ADD      r6,r0,r0,LSL #1
00136e  eb0406c6          ADD      r6,r4,r6,LSL #3
001372  7535              STRB     r5,[r6,#0x14]
001374  e013              B        |L1.5022|
                  |L1.4982|
;;;1001   		}
;;;1002   		else
;;;1003   		{
;;;1004   			(sf+i)->fcnt++;
001376  eb000540          ADD      r5,r0,r0,LSL #1
00137a  eb0405c5          ADD      r5,r4,r5,LSL #3
00137e  7d2d              LDRB     r5,[r5,#0x14]
001380  1c6d              ADDS     r5,r5,#1
001382  eb000640          ADD      r6,r0,r0,LSL #1
001386  eb0406c6          ADD      r6,r4,r6,LSL #3
00138a  7535              STRB     r5,[r6,#0x14]
;;;1005   			(sf+i)->ctime = (sf+i)->ltime;									 		//数据跳变，计数，并保存上一有效数据
00138c  eb000540          ADD      r5,r0,r0,LSL #1
001390  f8345035          LDRH     r5,[r4,r5,LSL #3]
001394  eb000640          ADD      r6,r0,r0,LSL #1
001398  eb0406c6          ADD      r6,r4,r6,LSL #3
00139c  8075              STRH     r5,[r6,#2]
                  |L1.5022|
00139e  1c45              ADDS     r5,r0,#1              ;995
0013a0  b2e8              UXTB     r0,r5                 ;995
                  |L1.5026|
0013a2  4288              CMP      r0,r1                 ;995
0013a4  dbc0              BLT      |L1.4904|
;;;1006   		}
;;;1007   	}
;;;1008   }
0013a6  bdf0              POP      {r4-r7,pc}
;;;1009   
                          ENDP

                  filter2 PROC
;;;1010   void filter2(sonar *sf, int len, int thred, int N)
0013a8  b570              PUSH     {r4-r6,lr}
;;;1011   {
0013aa  4604              MOV      r4,r0
;;;1012   	uint8_t i;
;;;1013   	for(i=0;i<len;i++)
0013ac  2000              MOVS     r0,#0
0013ae  e038              B        |L1.5154|
                  |L1.5040|
;;;1014   	{
;;;1015   		if( ( (sf+i)->ctime - (sf+i)->ltime ) < thred || (sf+i)->fcnt > N)
0013b0  eb000540          ADD      r5,r0,r0,LSL #1
0013b4  eb0405c5          ADD      r5,r4,r5,LSL #3
0013b8  886d              LDRH     r5,[r5,#2]
0013ba  eb000640          ADD      r6,r0,r0,LSL #1
0013be  f8346036          LDRH     r6,[r4,r6,LSL #3]
0013c2  1bad              SUBS     r5,r5,r6
0013c4  4295              CMP      r5,r2
0013c6  db06              BLT      |L1.5078|
0013c8  eb000540          ADD      r5,r0,r0,LSL #1
0013cc  eb0405c5          ADD      r5,r4,r5,LSL #3
0013d0  7d2d              LDRB     r5,[r5,#0x14]
0013d2  429d              CMP      r5,r3
0013d4  dd0f              BLE      |L1.5110|
                  |L1.5078|
;;;1016   		{
;;;1017   			(sf+i)->ltime = (sf+i)->ctime;
0013d6  eb000540          ADD      r5,r0,r0,LSL #1
0013da  eb0405c5          ADD      r5,r4,r5,LSL #3
0013de  886d              LDRH     r5,[r5,#2]
0013e0  eb000640          ADD      r6,r0,r0,LSL #1
0013e4  f8245036          STRH     r5,[r4,r6,LSL #3]
;;;1018   			(sf+i)->fcnt = 0;
0013e8  2500              MOVS     r5,#0
0013ea  eb000640          ADD      r6,r0,r0,LSL #1
0013ee  eb0406c6          ADD      r6,r4,r6,LSL #3
0013f2  7535              STRB     r5,[r6,#0x14]
0013f4  e013              B        |L1.5150|
                  |L1.5110|
;;;1019   		}
;;;1020   		else
;;;1021   		{
;;;1022   			(sf+i)->ctime = (sf+i)->ltime;
0013f6  eb000540          ADD      r5,r0,r0,LSL #1
0013fa  f8345035          LDRH     r5,[r4,r5,LSL #3]
0013fe  eb000640          ADD      r6,r0,r0,LSL #1
001402  eb0406c6          ADD      r6,r4,r6,LSL #3
001406  8075              STRH     r5,[r6,#2]
;;;1023   			(sf+i)->fcnt++;
001408  eb000540          ADD      r5,r0,r0,LSL #1
00140c  eb0405c5          ADD      r5,r4,r5,LSL #3
001410  7d2d              LDRB     r5,[r5,#0x14]
001412  1c6d              ADDS     r5,r5,#1
001414  eb000640          ADD      r6,r0,r0,LSL #1
001418  eb0406c6          ADD      r6,r4,r6,LSL #3
00141c  7535              STRB     r5,[r6,#0x14]
                  |L1.5150|
00141e  1c45              ADDS     r5,r0,#1              ;1013
001420  b2e8              UXTB     r0,r5                 ;1013
                  |L1.5154|
001422  4288              CMP      r0,r1                 ;1013
001424  dbc4              BLT      |L1.5040|
;;;1024   		}
;;;1025   	}
;;;1026   }
001426  bd70              POP      {r4-r6,pc}
;;;1027   
                          ENDP

                  test PROC
;;;1028   void test()
001428  b53e              PUSH     {r1-r5,lr}
;;;1029   {
;;;1030   	uint8_t buf[10];
;;;1031   	uint8_t TxCount;
;;;1032   	sprintf(buf,"%s\n","test");
00142a  a213              ADR      r2,|L1.5240|
00142c  a114              ADR      r1,|L1.5248|
00142e  4668              MOV      r0,sp
001430  f7fffffe          BL       __2sprintf
;;;1033   
;;;1034   	while(TxCount < sizeof(buf))
001434  e012              B        |L1.5212|
                  |L1.5174|
;;;1035   	{
;;;1036   		if(buf[TxCount] == '\0')break;
001436  f81d0004          LDRB     r0,[sp,r4]
00143a  b900              CBNZ     r0,|L1.5182|
00143c  e010              B        |L1.5216|
                  |L1.5182|
;;;1037   		USART_SendData(USART1,buf[TxCount++]);
00143e  4620              MOV      r0,r4
001440  1c62              ADDS     r2,r4,#1
001442  b2d4              UXTB     r4,r2
001444  f81d1000          LDRB     r1,[sp,r0]
001448  480a              LDR      r0,|L1.5236|
00144a  f7fffffe          BL       USART_SendData
;;;1038   		while(USART_GetFlagStatus(USART1,USART_FLAG_TC) == RESET);
00144e  bf00              NOP      
                  |L1.5200|
001450  2140              MOVS     r1,#0x40
001452  4808              LDR      r0,|L1.5236|
001454  f7fffffe          BL       USART_GetFlagStatus
001458  2800              CMP      r0,#0
00145a  d0f9              BEQ      |L1.5200|
                  |L1.5212|
00145c  2c0a              CMP      r4,#0xa               ;1034
00145e  d3ea              BCC      |L1.5174|
                  |L1.5216|
001460  bf00              NOP                            ;1036
;;;1039   	} 
;;;1040   }
001462  bd3e              POP      {r1-r5,pc}
;;;1041   											
                          ENDP

                  |L1.5220|
                          DCD      0x40012c00
                  |L1.5224|
                          DCD      0x40000400
                  |L1.5228|
                          DCD      0x40000800
                  |L1.5232|
                          DCD      TimingDelay
                  |L1.5236|
                          DCD      0x40013800
                  |L1.5240|
001478  74657374          DCB      "test",0
00147c  00      
00147d  00                DCB      0
00147e  00                DCB      0
00147f  00                DCB      0
                  |L1.5248|
001480  25730a00          DCB      "%s\n",0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  buff
                          %        200

                          AREA ||.data||, DATA, ALIGN=2

                  sequence
000000  0000              DCW      0x0000
                  index
000002  0000              DCW      0x0000
                  SafeTimer
000004  0000              DCW      0x0000
000006  0000              DCB      0x00,0x00
                  TimingDelay
                          DCD      0x00000000
                  Rstick
00000c  0000              DCB      0x00,0x00
                  Fstick
00000e  0000              DCB      0x00,0x00
                  Ufstick
000010  0000              DCB      0x00,0x00
                  Urstick
000012  0000              DCB      0x00,0x00
                  Rfstick
000014  0000              DCB      0x00,0x00
                  Rrstick
000016  0000              DCB      0x00,0x00
                  udir
000018  00                DCB      0x00
                  safe
000019  00                DCB      0x00
                  ||Ln||
00001a  00                DCB      0x00
                  Lfound
00001b  00                DCB      0x00
                  ||Rn||
00001c  00                DCB      0x00
                  Rfound
00001d  00                DCB      0x00
                  fire0
00001e  00                DCB      0x00
                  fire1
00001f  00                DCB      0x00
                  fire2
000020  00                DCB      0x00
                  fire3
000021  00                DCB      0x00
                  end0
000022  00                DCB      0x00
                  end1
000023  00                DCB      0x00
                  end2
000024  00                DCB      0x00
                  end3
000025  00                DCB      0x00
                  allfire
000026  00                DCB      0x00
                  allend
000027  00                DCB      0x00

                  __ARM_use_no_argv EQU 0
