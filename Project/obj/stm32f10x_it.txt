; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--debug -c --asm --interleave -o..\obj\stm32f10x_it.o --depend=..\obj\stm32f10x_it.d --cpu=Cortex-M3 --apcs=interwork -O0 -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\CMSIS\CM3\CoreSupport -I..\..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\..\User\inc -IC:\Keil\ARM\INC -IC:\Keil\ARM\INC\ST\STM32F10x -DSTM32F10X_MD -DUSE_STDPERIPH_DRIVER --omf_browse=..\obj\stm32f10x_it.crf ..\..\User\src\stm32f10x_it.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  NMI_Handler PROC
;;;54       */
;;;55     void NMI_Handler(void)
000000  4770              BX       lr
;;;56     {
;;;57     }
;;;58     
                          ENDP

                  HardFault_Handler PROC
;;;63       */
;;;64     void HardFault_Handler(void)
000002  bf00              NOP      
                  |L1.4|
;;;65     {
;;;66       /* Go to infinite loop when Hard Fault exception occurs */
;;;67       while (1)
000004  e7fe              B        |L1.4|
;;;68       {
;;;69       }
;;;70     }
;;;71     
                          ENDP

                  MemManage_Handler PROC
;;;76       */
;;;77     void MemManage_Handler(void)
000006  bf00              NOP      
                  |L1.8|
;;;78     {
;;;79       /* Go to infinite loop when Memory Manage exception occurs */
;;;80       while (1)
000008  e7fe              B        |L1.8|
;;;81       {
;;;82       }
;;;83     }
;;;84     
                          ENDP

                  BusFault_Handler PROC
;;;89       */
;;;90     void BusFault_Handler(void)
00000a  bf00              NOP      
                  |L1.12|
;;;91     {
;;;92       /* Go to infinite loop when Bus Fault exception occurs */
;;;93       while (1)
00000c  e7fe              B        |L1.12|
;;;94       {
;;;95       }
;;;96     }
;;;97     
                          ENDP

                  UsageFault_Handler PROC
;;;102      */
;;;103    void UsageFault_Handler(void)
00000e  bf00              NOP      
                  |L1.16|
;;;104    {
;;;105      /* Go to infinite loop when Usage Fault exception occurs */
;;;106      while (1)
000010  e7fe              B        |L1.16|
;;;107      {
;;;108      }
;;;109    }
;;;110    
                          ENDP

                  SVC_Handler PROC
;;;115      */
;;;116    void SVC_Handler(void)
000012  4770              BX       lr
;;;117    {
;;;118    }
;;;119    
                          ENDP

                  DebugMon_Handler PROC
;;;124      */
;;;125    void DebugMon_Handler(void)
000014  4770              BX       lr
;;;126    {
;;;127    }
;;;128    
                          ENDP

                  PendSV_Handler PROC
;;;133      */
;;;134    void PendSV_Handler(void)
000016  4770              BX       lr
;;;135    {
;;;136    }
;;;137    
                          ENDP

                  SysTick_Handler PROC
;;;142      */
;;;143    void SysTick_Handler(void)
000018  48d3              LDR      r0,|L1.872|
;;;144    {
;;;145    	extern uint32_t TimingDelay;
;;;146    	if(TimingDelay == 0)
00001a  6800              LDR      r0,[r0,#0]  ; TimingDelay
00001c  b940              CBNZ     r0,|L1.48|
;;;147    	{
;;;148    		SysTick->CTRL &= ~SysTick_CTRL_ENABLE_Msk;		
00001e  f04f20e0          MOV      r0,#0xe000e000
000022  6900              LDR      r0,[r0,#0x10]
000024  f0200001          BIC      r0,r0,#1
000028  f04f21e0          MOV      r1,#0xe000e000
00002c  6108              STR      r0,[r1,#0x10]
00002e  e004              B        |L1.58|
                  |L1.48|
;;;149    	}
;;;150    	else
;;;151    		TimingDelay--;
000030  48cd              LDR      r0,|L1.872|
000032  6800              LDR      r0,[r0,#0]  ; TimingDelay
000034  1e40              SUBS     r0,r0,#1
000036  49cc              LDR      r1,|L1.872|
000038  6008              STR      r0,[r1,#0]  ; TimingDelay
                  |L1.58|
;;;152    	SafeTimer++;		//安全时间
00003a  48cc              LDR      r0,|L1.876|
00003c  8800              LDRH     r0,[r0,#0]  ; SafeTimer
00003e  1c40              ADDS     r0,r0,#1
000040  49ca              LDR      r1,|L1.876|
000042  8008              STRH     r0,[r1,#0]
;;;153    }
000044  4770              BX       lr
;;;154    
                          ENDP

                  TIM4_IRQHandler PROC
;;;155    void TIM4_IRQHandler(void)
000046  b510              PUSH     {r4,lr}
;;;156    {
;;;157    
;;;158    	/*Group_4*/
;;;159    	if(TIM_GetFlagStatus(TIM4,TIM_FLAG_CC1) == SET)	
000048  2102              MOVS     r1,#2
00004a  48c9              LDR      r0,|L1.880|
00004c  f7fffffe          BL       TIM_GetFlagStatus
000050  2801              CMP      r0,#1
000052  d122              BNE      |L1.154|
;;;160    	{
;;;161    		s[index+12].beggin =  TIM_GetCapture1(TIM4);
000054  48c6              LDR      r0,|L1.880|
000056  f7fffffe          BL       TIM_GetCapture1
00005a  49c6              LDR      r1,|L1.884|
00005c  8809              LDRH     r1,[r1,#0]  ; index
00005e  310c              ADDS     r1,r1,#0xc
000060  eb010141          ADD      r1,r1,r1,LSL #1
000064  4ac4              LDR      r2,|L1.888|
000066  eb0201c1          ADD      r1,r2,r1,LSL #3
00006a  8088              STRH     r0,[r1,#4]
;;;162    		s[index+12].echo++;
00006c  48c1              LDR      r0,|L1.884|
00006e  8800              LDRH     r0,[r0,#0]  ; index
000070  300c              ADDS     r0,r0,#0xc
000072  eb000040          ADD      r0,r0,r0,LSL #1
000076  4611              MOV      r1,r2
000078  eb0100c0          ADD      r0,r1,r0,LSL #3
00007c  7c00              LDRB     r0,[r0,#0x10]
00007e  1c40              ADDS     r0,r0,#1
000080  b2c1              UXTB     r1,r0
000082  48bc              LDR      r0,|L1.884|
000084  8800              LDRH     r0,[r0,#0]  ; index
000086  300c              ADDS     r0,r0,#0xc
000088  eb000040          ADD      r0,r0,r0,LSL #1
00008c  eb0200c0          ADD      r0,r2,r0,LSL #3
000090  7401              STRB     r1,[r0,#0x10]
;;;163    		TIM_ClearITPendingBit(TIM4, TIM_IT_CC1);
000092  2102              MOVS     r1,#2
000094  48b6              LDR      r0,|L1.880|
000096  f7fffffe          BL       TIM_ClearITPendingBit
                  |L1.154|
;;;164    		
;;;165    	}
;;;166    
;;;167    	if(TIM_GetFlagStatus(TIM4,TIM_FLAG_CC2) == SET)	
00009a  2104              MOVS     r1,#4
00009c  48b4              LDR      r0,|L1.880|
00009e  f7fffffe          BL       TIM_GetFlagStatus
0000a2  2801              CMP      r0,#1
0000a4  d122              BNE      |L1.236|
;;;168    	{
;;;169    		s[index+12].end =  TIM_GetCapture2(TIM4);
0000a6  48b2              LDR      r0,|L1.880|
0000a8  f7fffffe          BL       TIM_GetCapture2
0000ac  49b1              LDR      r1,|L1.884|
0000ae  8809              LDRH     r1,[r1,#0]  ; index
0000b0  310c              ADDS     r1,r1,#0xc
0000b2  eb010141          ADD      r1,r1,r1,LSL #1
0000b6  4ab0              LDR      r2,|L1.888|
0000b8  eb0201c1          ADD      r1,r2,r1,LSL #3
0000bc  80c8              STRH     r0,[r1,#6]
;;;170    		s[index+12].echo++;
0000be  48ad              LDR      r0,|L1.884|
0000c0  8800              LDRH     r0,[r0,#0]  ; index
0000c2  300c              ADDS     r0,r0,#0xc
0000c4  eb000040          ADD      r0,r0,r0,LSL #1
0000c8  4611              MOV      r1,r2
0000ca  eb0100c0          ADD      r0,r1,r0,LSL #3
0000ce  7c00              LDRB     r0,[r0,#0x10]
0000d0  1c40              ADDS     r0,r0,#1
0000d2  b2c1              UXTB     r1,r0
0000d4  48a7              LDR      r0,|L1.884|
0000d6  8800              LDRH     r0,[r0,#0]  ; index
0000d8  300c              ADDS     r0,r0,#0xc
0000da  eb000040          ADD      r0,r0,r0,LSL #1
0000de  eb0200c0          ADD      r0,r2,r0,LSL #3
0000e2  7401              STRB     r1,[r0,#0x10]
;;;171    		TIM_ClearITPendingBit(TIM4, TIM_IT_CC2);
0000e4  2104              MOVS     r1,#4
0000e6  48a2              LDR      r0,|L1.880|
0000e8  f7fffffe          BL       TIM_ClearITPendingBit
                  |L1.236|
;;;172    		
;;;173    	}
;;;174    	
;;;175    }
0000ec  bd10              POP      {r4,pc}
;;;176    
                          ENDP

                  TIM3_IRQHandler PROC
;;;177    void TIM3_IRQHandler(void)
0000ee  b510              PUSH     {r4,lr}
;;;178    {
;;;179    
;;;180    	/*Group_3*/
;;;181    	if(TIM_GetFlagStatus(TIM3,TIM_FLAG_CC1) == SET)	
0000f0  2102              MOVS     r1,#2
0000f2  48a2              LDR      r0,|L1.892|
0000f4  f7fffffe          BL       TIM_GetFlagStatus
0000f8  2801              CMP      r0,#1
0000fa  d122              BNE      |L1.322|
;;;182    	{
;;;183    		s[index+8].beggin =  TIM_GetCapture1(TIM3);
0000fc  489f              LDR      r0,|L1.892|
0000fe  f7fffffe          BL       TIM_GetCapture1
000102  499c              LDR      r1,|L1.884|
000104  8809              LDRH     r1,[r1,#0]  ; index
000106  3108              ADDS     r1,r1,#8
000108  eb010141          ADD      r1,r1,r1,LSL #1
00010c  4a9a              LDR      r2,|L1.888|
00010e  eb0201c1          ADD      r1,r2,r1,LSL #3
000112  8088              STRH     r0,[r1,#4]
;;;184    		s[index+8].echo++;
000114  4897              LDR      r0,|L1.884|
000116  8800              LDRH     r0,[r0,#0]  ; index
000118  3008              ADDS     r0,r0,#8
00011a  eb000040          ADD      r0,r0,r0,LSL #1
00011e  4611              MOV      r1,r2
000120  eb0100c0          ADD      r0,r1,r0,LSL #3
000124  7c00              LDRB     r0,[r0,#0x10]
000126  1c40              ADDS     r0,r0,#1
000128  b2c1              UXTB     r1,r0
00012a  4892              LDR      r0,|L1.884|
00012c  8800              LDRH     r0,[r0,#0]  ; index
00012e  3008              ADDS     r0,r0,#8
000130  eb000040          ADD      r0,r0,r0,LSL #1
000134  eb0200c0          ADD      r0,r2,r0,LSL #3
000138  7401              STRB     r1,[r0,#0x10]
;;;185    		TIM_ClearITPendingBit(TIM2, TIM_IT_CC1);
00013a  2102              MOVS     r1,#2
00013c  0748              LSLS     r0,r1,#29
00013e  f7fffffe          BL       TIM_ClearITPendingBit
                  |L1.322|
;;;186    		
;;;187    	}
;;;188    
;;;189    	if(TIM_GetFlagStatus(TIM3,TIM_FLAG_CC2) == SET)	
000142  2104              MOVS     r1,#4
000144  488d              LDR      r0,|L1.892|
000146  f7fffffe          BL       TIM_GetFlagStatus
00014a  2801              CMP      r0,#1
00014c  d122              BNE      |L1.404|
;;;190    	{
;;;191    		s[index+8].end =  TIM_GetCapture2(TIM3);
00014e  488b              LDR      r0,|L1.892|
000150  f7fffffe          BL       TIM_GetCapture2
000154  4987              LDR      r1,|L1.884|
000156  8809              LDRH     r1,[r1,#0]  ; index
000158  3108              ADDS     r1,r1,#8
00015a  eb010141          ADD      r1,r1,r1,LSL #1
00015e  4a86              LDR      r2,|L1.888|
000160  eb0201c1          ADD      r1,r2,r1,LSL #3
000164  80c8              STRH     r0,[r1,#6]
;;;192    		s[index+8].echo++;
000166  4883              LDR      r0,|L1.884|
000168  8800              LDRH     r0,[r0,#0]  ; index
00016a  3008              ADDS     r0,r0,#8
00016c  eb000040          ADD      r0,r0,r0,LSL #1
000170  4611              MOV      r1,r2
000172  eb0100c0          ADD      r0,r1,r0,LSL #3
000176  7c00              LDRB     r0,[r0,#0x10]
000178  1c40              ADDS     r0,r0,#1
00017a  b2c1              UXTB     r1,r0
00017c  487d              LDR      r0,|L1.884|
00017e  8800              LDRH     r0,[r0,#0]  ; index
000180  3008              ADDS     r0,r0,#8
000182  eb000040          ADD      r0,r0,r0,LSL #1
000186  eb0200c0          ADD      r0,r2,r0,LSL #3
00018a  7401              STRB     r1,[r0,#0x10]
;;;193    		TIM_ClearITPendingBit(TIM3, TIM_IT_CC2);
00018c  2104              MOVS     r1,#4
00018e  487b              LDR      r0,|L1.892|
000190  f7fffffe          BL       TIM_ClearITPendingBit
                  |L1.404|
;;;194    		
;;;195    	}
;;;196    	
;;;197    }
000194  bd10              POP      {r4,pc}
;;;198    
                          ENDP

                  TIM2_IRQHandler PROC
;;;199    void TIM2_IRQHandler(void)
000196  b510              PUSH     {r4,lr}
;;;200    {
;;;201    	/*Group_2*/
;;;202    	if(TIM_GetFlagStatus(TIM2,TIM_FLAG_CC1) == SET)	
000198  2102              MOVS     r1,#2
00019a  0748              LSLS     r0,r1,#29
00019c  f7fffffe          BL       TIM_GetFlagStatus
0001a0  2801              CMP      r0,#1
0001a2  d122              BNE      |L1.490|
;;;203    	{
;;;204    		s[index+4].beggin =  TIM_GetCapture1(TIM2);
0001a4  0780              LSLS     r0,r0,#30
0001a6  f7fffffe          BL       TIM_GetCapture1
0001aa  4972              LDR      r1,|L1.884|
0001ac  8809              LDRH     r1,[r1,#0]  ; index
0001ae  1d09              ADDS     r1,r1,#4
0001b0  eb010141          ADD      r1,r1,r1,LSL #1
0001b4  4a70              LDR      r2,|L1.888|
0001b6  eb0201c1          ADD      r1,r2,r1,LSL #3
0001ba  8088              STRH     r0,[r1,#4]
;;;205    		s[index+4].echo++;
0001bc  486d              LDR      r0,|L1.884|
0001be  8800              LDRH     r0,[r0,#0]  ; index
0001c0  1d00              ADDS     r0,r0,#4
0001c2  eb000040          ADD      r0,r0,r0,LSL #1
0001c6  4611              MOV      r1,r2
0001c8  eb0100c0          ADD      r0,r1,r0,LSL #3
0001cc  7c00              LDRB     r0,[r0,#0x10]
0001ce  1c40              ADDS     r0,r0,#1
0001d0  b2c1              UXTB     r1,r0
0001d2  4868              LDR      r0,|L1.884|
0001d4  8800              LDRH     r0,[r0,#0]  ; index
0001d6  1d00              ADDS     r0,r0,#4
0001d8  eb000040          ADD      r0,r0,r0,LSL #1
0001dc  eb0200c0          ADD      r0,r2,r0,LSL #3
0001e0  7401              STRB     r1,[r0,#0x10]
;;;206    		TIM_ClearITPendingBit(TIM2, TIM_IT_CC1);
0001e2  2102              MOVS     r1,#2
0001e4  0748              LSLS     r0,r1,#29
0001e6  f7fffffe          BL       TIM_ClearITPendingBit
                  |L1.490|
;;;207    		
;;;208    	}
;;;209    
;;;210    	if(TIM_GetFlagStatus(TIM2,TIM_FLAG_CC2) == SET)	
0001ea  2104              MOVS     r1,#4
0001ec  0708              LSLS     r0,r1,#28
0001ee  f7fffffe          BL       TIM_GetFlagStatus
0001f2  2801              CMP      r0,#1
0001f4  d122              BNE      |L1.572|
;;;211    	{
;;;212    		s[index+4].end =  TIM_GetCapture2(TIM2);
0001f6  0780              LSLS     r0,r0,#30
0001f8  f7fffffe          BL       TIM_GetCapture2
0001fc  495d              LDR      r1,|L1.884|
0001fe  8809              LDRH     r1,[r1,#0]  ; index
000200  1d09              ADDS     r1,r1,#4
000202  eb010141          ADD      r1,r1,r1,LSL #1
000206  4a5c              LDR      r2,|L1.888|
000208  eb0201c1          ADD      r1,r2,r1,LSL #3
00020c  80c8              STRH     r0,[r1,#6]
;;;213    		s[index+4].echo++;
00020e  4859              LDR      r0,|L1.884|
000210  8800              LDRH     r0,[r0,#0]  ; index
000212  1d00              ADDS     r0,r0,#4
000214  eb000040          ADD      r0,r0,r0,LSL #1
000218  4611              MOV      r1,r2
00021a  eb0100c0          ADD      r0,r1,r0,LSL #3
00021e  7c00              LDRB     r0,[r0,#0x10]
000220  1c40              ADDS     r0,r0,#1
000222  b2c1              UXTB     r1,r0
000224  4853              LDR      r0,|L1.884|
000226  8800              LDRH     r0,[r0,#0]  ; index
000228  1d00              ADDS     r0,r0,#4
00022a  eb000040          ADD      r0,r0,r0,LSL #1
00022e  eb0200c0          ADD      r0,r2,r0,LSL #3
000232  7401              STRB     r1,[r0,#0x10]
;;;214    		TIM_ClearITPendingBit(TIM2, TIM_IT_CC2);
000234  2104              MOVS     r1,#4
000236  0708              LSLS     r0,r1,#28
000238  f7fffffe          BL       TIM_ClearITPendingBit
                  |L1.572|
;;;215    		
;;;216    	}
;;;217    
;;;218    	/*Group_1*/
;;;219    	if(TIM_GetFlagStatus(TIM2,TIM_FLAG_CC3) == SET)	
00023c  2108              MOVS     r1,#8
00023e  06c8              LSLS     r0,r1,#27
000240  f7fffffe          BL       TIM_GetFlagStatus
000244  2801              CMP      r0,#1
000246  d11e              BNE      |L1.646|
;;;220    	{
;;;221    		s[index].beggin =  TIM_GetCapture3(TIM2);
000248  0780              LSLS     r0,r0,#30
00024a  f7fffffe          BL       TIM_GetCapture3
00024e  4949              LDR      r1,|L1.884|
000250  8809              LDRH     r1,[r1,#0]  ; index
000252  eb010141          ADD      r1,r1,r1,LSL #1
000256  4a48              LDR      r2,|L1.888|
000258  eb0201c1          ADD      r1,r2,r1,LSL #3
00025c  8088              STRH     r0,[r1,#4]
;;;222    		s[index].echo++;
00025e  4845              LDR      r0,|L1.884|
000260  8800              LDRH     r0,[r0,#0]  ; index
000262  eb000040          ADD      r0,r0,r0,LSL #1
000266  4611              MOV      r1,r2
000268  eb0100c0          ADD      r0,r1,r0,LSL #3
00026c  7c00              LDRB     r0,[r0,#0x10]
00026e  1c40              ADDS     r0,r0,#1
000270  4940              LDR      r1,|L1.884|
000272  8809              LDRH     r1,[r1,#0]  ; index
000274  eb010141          ADD      r1,r1,r1,LSL #1
000278  eb0201c1          ADD      r1,r2,r1,LSL #3
00027c  7408              STRB     r0,[r1,#0x10]
;;;223    		TIM_ClearITPendingBit(TIM2, TIM_IT_CC3);
00027e  2108              MOVS     r1,#8
000280  06c8              LSLS     r0,r1,#27
000282  f7fffffe          BL       TIM_ClearITPendingBit
                  |L1.646|
;;;224    		
;;;225    	}
;;;226    
;;;227    	if(TIM_GetFlagStatus(TIM2,TIM_FLAG_CC4) == SET)	
000286  2110              MOVS     r1,#0x10
000288  0688              LSLS     r0,r1,#26
00028a  f7fffffe          BL       TIM_GetFlagStatus
00028e  2801              CMP      r0,#1
000290  d11e              BNE      |L1.720|
;;;228    	{
;;;229    		s[index].end =  TIM_GetCapture4(TIM2);
000292  0780              LSLS     r0,r0,#30
000294  f7fffffe          BL       TIM_GetCapture4
000298  4936              LDR      r1,|L1.884|
00029a  8809              LDRH     r1,[r1,#0]  ; index
00029c  eb010141          ADD      r1,r1,r1,LSL #1
0002a0  4a35              LDR      r2,|L1.888|
0002a2  eb0201c1          ADD      r1,r2,r1,LSL #3
0002a6  80c8              STRH     r0,[r1,#6]
;;;230    		s[index].echo++;
0002a8  4832              LDR      r0,|L1.884|
0002aa  8800              LDRH     r0,[r0,#0]  ; index
0002ac  eb000040          ADD      r0,r0,r0,LSL #1
0002b0  4611              MOV      r1,r2
0002b2  eb0100c0          ADD      r0,r1,r0,LSL #3
0002b6  7c00              LDRB     r0,[r0,#0x10]
0002b8  1c40              ADDS     r0,r0,#1
0002ba  492e              LDR      r1,|L1.884|
0002bc  8809              LDRH     r1,[r1,#0]  ; index
0002be  eb010141          ADD      r1,r1,r1,LSL #1
0002c2  eb0201c1          ADD      r1,r2,r1,LSL #3
0002c6  7408              STRB     r0,[r1,#0x10]
;;;231    		TIM_ClearITPendingBit(TIM2, TIM_IT_CC4);
0002c8  2110              MOVS     r1,#0x10
0002ca  0688              LSLS     r0,r1,#26
0002cc  f7fffffe          BL       TIM_ClearITPendingBit
                  |L1.720|
;;;232    		
;;;233    	}
;;;234    	
;;;235    }
0002d0  bd10              POP      {r4,pc}
;;;236    
                          ENDP

                  TIM1_CC_IRQHandler PROC
;;;237    void TIM1_CC_IRQHandler(void)
0002d2  4770              BX       lr
;;;238    {
;;;239    //	if(TIM_GetFlagStatus(TIM1,TIM_FLAG_CC1) == SET)	
;;;240    //	{
;;;241    //		s[index].beggin =  TIM_GetCapture1(TIM1);
;;;242    //		TIM_ClearITPendingBit(TIM1, TIM_IT_CC1);
;;;243    //		s[index].echo++;
;;;244    //	}
;;;245    //
;;;246    //	if(TIM_GetFlagStatus(TIM1,TIM_FLAG_CC2) == SET)	
;;;247    //	{
;;;248    //		s[index].end =  TIM_GetCapture2(TIM1);
;;;249    //		TIM_ClearITPendingBit(TIM1, TIM_IT_CC4);
;;;250    //		s[index].echo++;
;;;251    //	}
;;;252    
;;;253    }
;;;254    
                          ENDP

                  USART1_IRQHandler PROC
;;;255    void USART1_IRQHandler(void)
0002d4  b510              PUSH     {r4,lr}
;;;256    {
;;;257    
;;;258    	uint8_t temp;
;;;259    	temp = USART_ReceiveData(USART1);
0002d6  482a              LDR      r0,|L1.896|
0002d8  f7fffffe          BL       USART_ReceiveData
0002dc  b2c4              UXTB     r4,r0
;;;260    
;;;261    //	USART_SendData(USART1,0xaa);
;;;262    //	test();
;;;263    	SafeTimer = 0;
0002de  2000              MOVS     r0,#0
0002e0  4922              LDR      r1,|L1.876|
0002e2  8008              STRH     r0,[r1,#0]
;;;264    	switch(RxCtl.cnt)
0002e4  4827              LDR      r0,|L1.900|
0002e6  f990000f          LDRSB    r0,[r0,#0xf]  ; RxCtl
0002ea  b120              CBZ      r0,|L1.758|
0002ec  2801              CMP      r0,#1
0002ee  d00b              BEQ      |L1.776|
0002f0  280e              CMP      r0,#0xe
0002f2  d126              BNE      |L1.834|
0002f4  e017              B        |L1.806|
                  |L1.758|
;;;265    	{
;;;266    		case 0:
;;;267    			if(temp == 0xee)
0002f6  2cee              CMP      r4,#0xee
0002f8  d105              BNE      |L1.774|
;;;268    			{
;;;269    				RxCtl.cnt++;
0002fa  4822              LDR      r0,|L1.900|
0002fc  7bc0              LDRB     r0,[r0,#0xf]  ; RxCtl
0002fe  1c40              ADDS     r0,r0,#1
000300  b240              SXTB     r0,r0
000302  4920              LDR      r1,|L1.900|
000304  73c8              STRB     r0,[r1,#0xf]
                  |L1.774|
;;;270    				
;;;271    			}
;;;272    			break;
000306  e028              B        |L1.858|
                  |L1.776|
;;;273    		case 1:
;;;274    			if(temp == 0xaa)
000308  2caa              CMP      r4,#0xaa
00030a  d108              BNE      |L1.798|
;;;275    			{
;;;276    				RxCtl.cnt++;
00030c  481d              LDR      r0,|L1.900|
00030e  7bc0              LDRB     r0,[r0,#0xf]  ; RxCtl
000310  1c40              ADDS     r0,r0,#1
000312  b240              SXTB     r0,r0
000314  491b              LDR      r1,|L1.900|
000316  73c8              STRB     r0,[r1,#0xf]
;;;277    				RxCtl.finish = 0;			//开始接收帧，结束标志复位
000318  2000              MOVS     r0,#0
00031a  7408              STRB     r0,[r1,#0x10]
00031c  e002              B        |L1.804|
                  |L1.798|
;;;278    			}
;;;279    			else
;;;280    			{
;;;281    				RxCtl.cnt = 0;
00031e  2000              MOVS     r0,#0
000320  4918              LDR      r1,|L1.900|
000322  73c8              STRB     r0,[r1,#0xf]
                  |L1.804|
;;;282    			}
;;;283    			break;
000324  e019              B        |L1.858|
                  |L1.806|
;;;284    		case 14:
;;;285    			if(temp == 0xbb)
000326  2cbb              CMP      r4,#0xbb
000328  d10a              BNE      |L1.832|
;;;286    			{
;;;287    				RxCtl.buffer[0] = 0xee;
00032a  20ee              MOVS     r0,#0xee
00032c  4915              LDR      r1,|L1.900|
00032e  7008              STRB     r0,[r1,#0]
;;;288    				RxCtl.buffer[1] = 0xaa;
000330  20aa              MOVS     r0,#0xaa
000332  7048              STRB     r0,[r1,#1]
;;;289    				RxCtl.finish = 1;			//帧结束标志
000334  2001              MOVS     r0,#1
000336  7408              STRB     r0,[r1,#0x10]
;;;290    				RxCtl.cnt = 0;
000338  2000              MOVS     r0,#0
00033a  73c8              STRB     r0,[r1,#0xf]
;;;291    				RxCtl.updated = 1;
00033c  2001              MOVS     r0,#1
00033e  7448              STRB     r0,[r1,#0x11]
                  |L1.832|
;;;292    		//		USART_SendData(USART1,RxCtl.buffer[11]);
;;;293    			}
;;;294    			break;
000340  e00b              B        |L1.858|
                  |L1.834|
;;;295    		default:
;;;296    			RxCtl.buffer[RxCtl.cnt++] = temp;
000342  b261              SXTB     r1,r4
000344  480f              LDR      r0,|L1.900|
000346  f990200f          LDRSB    r2,[r0,#0xf]  ; RxCtl
00034a  7bc0              LDRB     r0,[r0,#0xf]  ; RxCtl
00034c  1c40              ADDS     r0,r0,#1
00034e  b240              SXTB     r0,r0
000350  4b0c              LDR      r3,|L1.900|
000352  73d8              STRB     r0,[r3,#0xf]
000354  4618              MOV      r0,r3
000356  5481              STRB     r1,[r0,r2]
;;;297    			break;
000358  bf00              NOP      
                  |L1.858|
00035a  bf00              NOP                            ;272
;;;298    
;;;299    	}
;;;300    	USART_ClearITPendingBit(USART1,USART_IT_RXNE);
00035c  f2405125          MOV      r1,#0x525
000360  4807              LDR      r0,|L1.896|
000362  f7fffffe          BL       USART_ClearITPendingBit
;;;301    }
000366  bd10              POP      {r4,pc}
;;;302    
                          ENDP

                  |L1.872|
                          DCD      TimingDelay
                  |L1.876|
                          DCD      SafeTimer
                  |L1.880|
                          DCD      0x40000800
                  |L1.884|
                          DCD      index
                  |L1.888|
                          DCD      s
                  |L1.892|
                          DCD      0x40000400
                  |L1.896|
                          DCD      0x40013800
                  |L1.900|
                          DCD      RxCtl
